[
  {
    "objectID": "projects.html",
    "href": "projects.html",
    "title": "Data Simulation",
    "section": "",
    "text": "This section describes the steps to simulate occurrence data for fitting spatially explicit occupancy models in R-INLA."
  },
  {
    "objectID": "projects.html#state-process-model-sub-component",
    "href": "projects.html#state-process-model-sub-component",
    "title": "Data Simulation",
    "section": "\n2.1 State process model sub-component",
    "text": "2.1 State process model sub-component\nDefine model parameters \\(\\beta\\) and compute the occupancy probabilities \\(\\psi\\) and occupancy states \\(z\\) (Figure 3)\n\nCode# State process model coeficcients\nbeta &lt;- c(NA,NA)\nbeta[1] &lt;-  qlogis(0.3) # Base line occupancy probability\nbeta[2] &lt;- 1.5  # environmental covariate effect\n\n# Occupancy probabilities\npsi &lt;- inla.link.logit(beta[1] + beta[2]*x_s + omega_s, inverse = T)\n\n# True occupancy state\n\nset.seed(seed)\nz &lt;- rbinom(ncells, size = 1, prob = psi)\n\n\n\n\n\n\nFigure 3: Simulated occupancy probabilities and true presence/absence state"
  },
  {
    "objectID": "projects.html#observational-process-model-sub-component",
    "href": "projects.html#observational-process-model-sub-component",
    "title": "Data Simulation",
    "section": "\n2.2 Observational process model sub-component",
    "text": "2.2 Observational process model sub-component\nRandom sample of 20 % of the total cells and draw a random number of \\(K\\) visits per cell by setting a minimum of 1 and a maximum of 5 visits per site/cell.\n\nCode# number of cells/sites in the sample\nnsites = round(ncells*.20)\nsite_id = sample(1:ncells, size=nsites, replace=FALSE) # cell id\n# add an indicator of whether a cell is in the sample or not\ncustomGrid$sample &lt;- ifelse(customGrid$cellid%in%site_id,1,0)\n\nmin_nvisits = 1 # minimum number of visits\nmax_nvisits = 5 # maximum number of visits\n# Probabiliies of drawing 1 thru 5 visits per site\nprobs = rep(1/length(min_nvisits:max_nvisits),length(min_nvisits:max_nvisits))\n# Number of visits\nnvisits = sample(min_nvisits:max_nvisits,nsites, prob = probs, replace = T)\n\n\nDefine model parameters \\(\\alpha\\) , detection probabilities \\(p\\) and observed number of occurrences per site \\(y\\) (Figure 4):\n\nCode# Observational process model coeficcients\nalpha &lt;- c(NA,NA)\nalpha[1] &lt;- qlogis(0.6) # Base line detection probability\nalpha[2] &lt;- 1 # detection covariate effect\n\n# Detection probabilities\np &lt;- inla.link.logit(alpha[1] + alpha[2]*g_s[site_id], inverse = T)\ny &lt;- rbinom(n = nsites,size = nvisits,prob = p*z[site_id] )\n\n\nCreate data set Table 1:\n\nCode# centroid of the cell\n\nOcc_data_1 &lt;- customGrid |&gt;\n  st_centroid() |&gt;\n  filter(sample==1) |&gt;\n  dplyr::select(-c('sample'))\n\ny_counts = data.frame(y = y , cellid = site_id, nvisits = nvisits)\n\nOcc_data_1 &lt;- left_join(Occ_data_1,y_counts,by = \"cellid\")\n\n# append coordinates as columns\n\nOcc_data_1[,c('x.loc','y.loc')] &lt;- st_coordinates(Occ_data_1)\nOcc_data_1 = st_drop_geometry(Occ_data_1)\n# Save CSV file for analysis\nwrite.csv(Occ_data_1,file='Occ_data_1.csv',row.names = F)\n\n\n\n\n\n\nTable 1: First 6 entries of the occupancy data\n\ncellid\ny\nnvisits\nx.loc\ny.loc\n\n\n\n2\n0\n5\n4.5\n1.5\n\n\n5\n1\n4\n13.5\n1.5\n\n\n6\n0\n3\n16.5\n1.5\n\n\n7\n2\n5\n19.5\n1.5\n\n\n9\n0\n1\n25.5\n1.5\n\n\n23\n0\n4\n67.5\n1.5\n\n\n\n\n\n\n\n\n\n\nFigure 4: Number of times species was detected at sampled sites and true occupancy state."
  },
  {
    "objectID": "projects.html#footnotes",
    "href": "projects.html#footnotes",
    "title": "Data Simulation",
    "section": "Footnotes",
    "text": "Footnotes\n\nNote: If you are using INLA development version you might need modify the book.rspde function. Specifically, change the inla.mesh.project function to fmesher::fm_evaluator function to project the mesh into the domain coordinates.↩︎"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Fitting Occupancy models with R-INLA",
    "section": "",
    "text": "This section describes the steps to fit occupancy models in R-INLA using simulated data (simulation details can be found in the Data Simulation tab)."
  },
  {
    "objectID": "index.html#sec-setup1",
    "href": "index.html#sec-setup1",
    "title": "Fitting Occupancy models with R-INLA",
    "section": "\n1.1 Set up",
    "text": "1.1 Set up\nWe first load the data and prepare it in the format that is required by R-INLA.\n\nCodelibrary(INLA)\nlibrary(inlabru)\nlibrary(fmesher)\nlibrary(tidyverse)\nlibrary(sf)\nlibrary(terra)\nlibrary(dplyr)\n\n\nSSOM &lt;- read.csv(\"Occ_data_1.csv\")\nx_covariate &lt;- terra::rast('raster data/x_covariat.tif')\ng_covariate &lt;- terra::rast('raster data/g_covariat.tif')\n\n# Extract the covariate values\n\n# Convert to sf \nSSOM &lt;- SSOM %&gt;%\n  st_as_sf(coords = c('x.loc','y.loc')) \n\n# evaluate covariates at each cell \n\nSSOM = SSOM %&gt;% dplyr::select(-cellid) %&gt;% \n        mutate(terra::extract(x_covariate,st_coordinates(SSOM)),\n               terra::extract(g_covariate,st_coordinates(SSOM)))\n\n\n\n\n\n\nTable 1: First 6 entries of the occupancy data\n\ny\nnvisits\ngeometry\nx_s\ng_s\n\n\n\n0\n5\nPOINT (4.5 1.5)\n0.2478524\n-0.6723235\n\n\n1\n4\nPOINT (13.5 1.5)\n0.7923162\n-0.9056783\n\n\n0\n3\nPOINT (16.5 1.5)\n0.7719001\n-0.9741012\n\n\n2\n5\nPOINT (19.5 1.5)\n0.8750099\n-1.1154522\n\n\n0\n1\nPOINT (25.5 1.5)\n0.6873934\n-1.2286578\n\n\n0\n4\nPOINT (67.5 1.5)\n0.9882513\n-0.5804850\n\n\n\n\n\n\n\n\n\n Download data as xlsx\n\n\n\n Download g raster file\n\n\n\n\n Download x raster file\n\n\n\n\n\n1.1.1 Constructing the mesh and defining the SPDE\nThe linear predictor can include a variety of random effects such as smooth terms or spatiotemporal components by incorporating Gaussian random fields (GRFs) into models. This is achieved by using the stochastic partial differential equation (SPDE) method introduced by Lindgren, Rue, and Lindström (2011). The SPDE approach relies discretizing the space by defining a mesh that creates an artificial set of neighbours over the study area that allows for the spatial autocorrelation between observation to be calculated. How the mesh is constructed will have an important impact on the inference and predictions we make. Thus, it is important to create a good mesh to ensure results are not sensible to the mesh itself (guidance for creating a mesh can be found in Krainski et al. (2018) section 2.6.3). The inla.spde2.pcmatern() function is used to define the SPDE model. Using the penalized complexity (PC) priors derived in Fuglstad et al. (2018) on the range and marginal standard deviation.\n\nCodeboundary_sf = st_bbox(c(xmin = 0, xmax = 300, ymax = 0, ymin = 300)) |&gt;\n  st_as_sfc()\n\nmesh = fm_mesh_2d(loc.domain = st_coordinates(boundary_sf)[,1:2],\n                    offset = c(-0.1, -.2),\n                    max.edge = c(15, 30))\nmatern &lt;- inla.spde2.pcmatern(mesh,\n                              prior.range = c(100, 0.5),\n                              prior.sigma = c(1, 0.5))\n\n\n\n\n\n\n\n\n\n\nTo define a spatial model we create the projector A matrix that maps the spatial Gaussian random field to the locations of the observed data and organize it along with the data, indeces and covariates through the inla.stack() function (see Krainski et al. (2018) sections 2.3.2 and 2.3.3 for more details).\nWhen building the stack we need to supply three main arguments:\n\nList containing the data, the detection site-level covariate(s), the number of visits per site, and vector of 1’s of length \\(M_{sites}\\) for the detection intercept.\nList of projector matrices (in this case the projector matrix A for the spatial field and a matrix that maps the covariate and the response)\nList of effects including (i) the occupancy intercept, (ii) the index set for the spatial field (that takes into account the number of mesh points in the SPDE ) and (iii) a list of the site-level covariate(s) for the state process of interest.\n\n\n# projector matrix A\nA_sp &lt;- inla.spde.make.A(mesh = mesh,\n                      loc = st_coordinates(SSOM))\n# index set\niset_sp &lt;- inla.spde.make.index(name = \"spatial_field\", matern$n.spde)\n\n# build the stack\n# stk &lt;- inla.stack(data=list(Ycounts = SSOM$y, # observed occurrences\n#                             Ncounts = SSOM$nvisits, # number of visits\n#                             det_cov = SSOM$g_s, # detection covariate\n#                             Int_det = rep(1,length(SSOM$y))), # Det Intercept\n#                   A=list(A_sp,1),  # project matrices\n#                   effects=list(c(list(Int_occ=1), # Occ Intercept\n#                                  iset_sp),  #the spatial index\n#                                # the covariates\n#                                list(occ_cov = SSOM$x_s)),\n#                   #this is a quick name so yo can call upon easily\n#                   tag='ssom')\n\n# build the stack\nstk &lt;- inla.stack(data=list(Ycounts = SSOM$y, # observed occurrences\n                            Ncounts = SSOM$nvisits, # number of visits\n                            det_cov = SSOM$g_s, # detection covariate\n                            Int_det = rep(1,length(SSOM$y))), # Det Intercept\n                  A=list(A_sp,1),  # project matrices\n                  effects=list(iset_sp, #the spatial index\n                               data.frame(Int_occ=1,  # Occ Intercept\n                                          occ_cov = SSOM$x_s)), # covariate x\n                  #this is a quick name so yo can call upon easily\n                  tag='ssom')\n\nNow we define the model components (left hand side -observational model components; right hand side - state process components) and fit the model:\n\nformula_ssom &lt;- inla.mdata(cbind(Ycounts,Ncounts),Int_det,det_cov) ~  -1 +\n  Int_occ +  occ_cov +  f(spatial_field, model=matern)\n\nmodel_ssom &lt;- inla(formula_ssom, # model formula\n                 data=inla.stack.data(stk), # data stack\n                 family= '0binomialS', # model likelihood\n                 # priors\n                 control.fixed =  list(prec = 1/2.72, prec.intercept = 1/2.72),\n                 # matrix of predictors\n                 control.predictor=list(A=inla.stack.A(stk),compute=TRUE),\n                 # compute WAIC and DIC\n                 control.compute = list(dic = TRUE, waic = TRUE, config = TRUE),\n                 verbose = FALSE,\n                 # choose link functions for:\n                 # (i) the state process (control.link)\n                 # (ii) the observation process (link.simple)\n                 control.family = list(control.link = list(model = \"logit\"),\n                                       link.simple = \"logit\",\n                 # priors for hyperparameters\n                 hyper = list(\n                   beta1 = list(param = c(0,1), initial = -1),\n                   beta2 = list(param = c(0,1/2.72)))\n                 )\n                 )\n\n\n\n\n\n\n\nNote\n\n\n\nWe explicitly removed the intercepts in the formula and included them as covariates in the list of effects and data. Then, the covariate terms (which are now included in the projector matrix) are passed on to inla() through the control.predictor argument."
  },
  {
    "objectID": "index.html#results",
    "href": "index.html#results",
    "title": "Fitting Occupancy models with R-INLA",
    "section": "\n1.2 Results",
    "text": "1.2 Results\nThe summary of the fixed effect, namely \\(\\beta_0\\) and \\(\\beta_1\\) can be retrieved from model_ssom$summary.fixed while detection parameters \\(\\alpha_0\\) and \\(\\alpha_1\\) are contained, along with the range and standard deviation, in model_ssom$summary.hyperpar.\n\n\n\n\n\n\nNote\n\n\n\nNotice that INLA’s parametrization of a ZIB model is\n\\[ \\pi(y|\\eta_1,\\eta_2) = p(\\eta_1)\\mathbb{I}_{y=0} + (1 - p(\\eta_1))\\pi(y|\\eta_2) \\]\nFor the occupancy model, the occupancy probabilities can be defined as \\(\\psi = 1-p(\\eta_1)\\) and \\(\\pi(y|\\eta_2)\\) is a Binomial likelihood.\nIf we use the the logit link function, we can get the linear predictor in the appropriate scale by defining\n\\[\n\\psi = 1 -\\dfrac{\\mathrm{exp}(\\eta_1)}{1+\\mathrm{exp}(\\eta_1)}= \\dfrac{1}{1+\\mathrm{exp}(\\eta_1)} = \\dfrac{\\mathrm{exp}(-\\eta_1)}{1+ \\mathrm{exp}(-\\eta_1)}\n\\]\nThus, we can transform the posterior marginal for the occupancy state process parameters using the inla.tmarginal() function. E.g., the marginal distribution of \\(\\beta_0\\) can be obtained using:\ninla.tmarginal(function(x) -x, model_ssom$marginals.fixed$Int_occ)\nSummaries can then be computed using the inla.zmarginal() function.\n\n\nSummary results from the fitted SSOM are shown in Table 2 and posterior densities on Figure 1.\n\n\n\n\nTable 2: summary results for the occupancy model parameters and their corresponding true values.\n\npar\ntrue\nmean\nquant0.025\nquant0.975\n\n\n\n\\(\\beta_0\\)\n-0.85\n-1.18\n-1.64\n-0.64\n\n\n\\(\\beta_1\\)\n1.50\n1.50\n1.23\n1.77\n\n\n\\(\\alpha_0\\)\n0.41\n0.48\n0.36\n0.59\n\n\n\\(\\alpha_1\\)\n1.00\n0.94\n0.82\n1.06\n\n\n\\(\\rho\\)\n100.00\n77.44\n33.30\n163.87\n\n\n\\(\\sigma\\)\n1.00\n0.78\n0.54\n1.08\n\n\n\n\n\n\n\n\n\n\nFigure 1: Posterior densities of the fixed effect parameters of a simple spatial occupancy model fitted with R-INLA.The vertical solid line represent the true value of the parameter."
  },
  {
    "objectID": "index.html#model-comparison-through-cross-validation",
    "href": "index.html#model-comparison-through-cross-validation",
    "title": "Fitting Occupancy models with R-INLA",
    "section": "\n1.3 Model comparison through cross-validation",
    "text": "1.3 Model comparison through cross-validation\nNext we introduce how to implement modelling comparison using leave-out group cross validation (LGOCV). The underlying idea is that of a Bayesian prediction setting where we approximate the posterior predictive density \\(\\pi(\\mathbf{\\tilde{Y}}|\\mathbf{y})\\) defined as the integral over the posterior distribution of the parameters, i.e.\n\\[\n\\pi(\\mathbf{\\tilde{Y}}|\\mathbf{y}) = \\int_\\theta \\pi(\\mathbf{\\tilde{Y}}|\\theta,\\mathbf{y}) \\pi(\\theta|\\mathbf{y})d\\theta\n\\]\nthe LGOCV selects a fixed test point \\(i\\) and remove a certain group of data \\(\\mathbb{I}_i\\) according to a specific prediction task. Thus, we are interested in the posterior predictive density\n\\[\n\\pi(Y_i|\\mathbf{y}_{-\\mathcal{I}_i}) = \\int_\\theta \\pi(Y_i|\\theta,\\mathbf{y}_{-\\mathbb{I}_i}) \\pi(\\theta|\\mathbf{y})d\\theta\n\\]\nWith this, a point estimate \\(\\tilde{Y_i}\\) can be computed based on \\(\\pi(Y_i|\\mathbf{y}_{-\\mathbb{I}_i})\\) and the predictive performance be assessed using an appropriate scoring function \\(U(\\tilde{Y}_i,Y_i)\\), for example, the log-score function\n\\[\n\\frac{1}{n}\\sum_{i=1}^n \\mathrm{log}~ \\pi(\\mathbf{\\tilde{y}}|\\mathbf{y}).\n\\]\nIn this example, the LGOCV strategy will be used to compare the previous fitted spatially explicit occupancy model against a simple model that only considers a site iid random effect (note that since no structured spatial effect is being included, the data can be passed on to inla() without the need for a stack).\n\nSSOM_simple = SSOM %&gt;%\n  mutate(site= 1:nrow(SSOM),Int_det = 1) %&gt;%\n  st_drop_geometry()\n\nformula_simple = inla.mdata(cbind(y,nvisits),Int_det,g_s) ~\n   f(site, model =  \"iid\")\n\nmodel_simple &lt;- inla(formula_simple, data=SSOM_simple,\n                     family= '0binomialS',verbose = FALSE,\n               control.compute = list( config = TRUE,dic  = T, waic = T),\n               control.fixed = list(prec.intercept = 1/2.72,prec = 1/2.72),\n               control.family = list(control.link = list(model = \"logit\"),\n                                     link.simple = \"logit\",\n                                     hyper = list(beta1 = list(param = c(0,1),\n                                                           initial = 0),\n                                                  beta2 = list(param = c(0,1)))))\n\nIn this example the leave-out group \\(\\mathbb{I}_i\\) is manually defined for the \\(i\\)th row of the data based on a buffer of size \\(b=25\\) centered at each data point:\n\nCode# create buffer of size 25 centred at each site\nbuffer &lt;- st_buffer(SSOM, dist = 25)\n# Lists of the indexes of the leave-out-group for each observation i\nIi &lt;- st_intersects(SSOM,buffer)\n\n\n\n\n\n\nFigure 2: Example of the CV strategy for the 500th testing point.\n\n\n\nThe LGOCV is used to evaluate the predictive performance of each model and the log-scores are computed as shown in Table 3).\n\nCodelgocv_ssom = inla.group.cv(result = model_ssom, groups= Ii)\nlgocv_simple = inla.group.cv(result = model_simple, group.cv = lgocv_ssom)\n\nlog_score_ssom &lt;- mean(log(lgocv_ssom$cv),na.rm=T)\nlog_score_simple &lt;-mean(log(lgocv_simple$cv),na.rm=T)\n\n\n\n\n\n\n\n\n\nTable 3:  Leave group out CV log scores of a spatially explicit occupancy model\nand a simple occupancy model with a site iid random effect. \n  \n\nLog-Score LGOCV\n    \n\nContinuous spatial Gaussian field\n       Site iid random effect\n    \n\n\n−0.70\n−0.83"
  },
  {
    "objectID": "index.html#set-up",
    "href": "index.html#set-up",
    "title": "Fitting Occupancy models with R-INLA",
    "section": "\n2.1 Set up",
    "text": "2.1 Set up\nFirst, we need the data to have the correct structure with columns representing the observed occurrences, number of visits, the cell/site id, the site-level covariates, and the time points. An additional filtering is made to remove the locations that were not visited in a given time point.\n\nCodespace_time_data &lt;- read.csv(\"Occ_data_2.csv\")\nx_covariate &lt;- terra::rast('raster data/x_covariat.tif')\n\n# Convert to sf\nspace_time_data &lt;- space_time_data %&gt;%\n  st_as_sf(coords = c('x.loc','y.loc')) %&gt;%\n   rename_with(~ str_remove(., \"\\\\.\"), everything())\n\n# evaluate covariates at each cell and convert to long format\n\nspace_time_data &lt;- space_time_data %&gt;%\n  dplyr::select(-cellid) %&gt;%\n        mutate(site = 1:nrow(space_time_data),\n               terra::extract(x_covariate,st_coordinates(space_time_data)),\n               terra::extract(g_covariate,st_coordinates(space_time_data)))%&gt;%\n        pivot_longer(cols = starts_with(c(\"n\",\"y\")),\n                     cols_vary = \"slowest\",\n                     names_to = c(\".value\", \"time\"),\n                     names_pattern = \"(.*)(.)\") %&gt;%\n        mutate(nvisits = if_else(is.na(nvisits),0,nvisits),\n               time = as.numeric(time)) %&gt;%\n  dplyr::filter(nvisits &gt; 0) # remove locations that were not visited\n\n\n\n\n\nFirst 6 entries of the occupancy spatiotemporal data \n\ngeometry\nsite\nx_s\ng_s\ntime\nnvisits\ny\n\n\n\nPOINT (4.5 1.5)\n1\n0.2478524\n-0.6723235\n1\n5\n3\n\n\nPOINT (13.5 1.5)\n2\n0.7923162\n-0.9056783\n1\n5\n1\n\n\nPOINT (19.5 1.5)\n4\n0.8750099\n-1.1154522\n1\n1\n0\n\n\nPOINT (25.5 1.5)\n5\n0.6873934\n-1.2286578\n1\n1\n0\n\n\nPOINT (67.5 1.5)\n6\n0.9882513\n-0.5804850\n1\n5\n0\n\n\nPOINT (91.5 1.5)\n7\n0.8988259\n0.3230207\n1\n3\n0\n\n\n\n\n\n\n\n Download data as xlsx\n\n\nFor the estimation of the smooth effect, we can reduce the number of knots used in the estimation process by grouping the covariate \\(x\\) values into equal length intervals with the inla.group() function and appending these grouped values to the data.\n\n\n\n\n\n\nImportant\n\n\n\nAt this point we will also create a data frame for prediction, containing the values of the binned covariates \\(x\\) for every time time point in the data.\n\n\n\nnT &lt;- length(space_time_data$time %&gt;% unique) # number of time points\nncells &lt;- length(values(x_covariate$x_s)) # number of cells in the area\n\n# scale and centre the covariate value in the data input\nspace_time_data &lt;- space_time_data %&gt;%\n  mutate(scale_x_s = scale(x_s)  %&gt;% c())\n\n# prediction data frame\npred_df = data.frame(x = rep(crds(x_covariate)[,1],nT),\n                     y = rep(crds(x_covariate)[,2],nT),\n                     x_s = rep(as.vector(scale(values(x_covariate$x_s))),nT),\n                     time = rep(c(1:nT), each= ncells))\n\n# binned covariate values.\nxx = inla.group(c(space_time_data$x_s, pred_df$x_s),\n                n = 35)\n\n# append grouped covariate values to the input and prediction data sets\nspace_time_data$group_xs = xx[1:dim(space_time_data)[1]]\npred_df$group_xs = xx[-c(1:dim(space_time_data)[1])]\n\nTo fit a separable space time model, the SPDE and the index set need to be defined (see Krainski et al. (2018) Section 7.1.2 for further reference on building the stack for a separable space time model in INLA). Note that for building the projection matrix A, the coordinates and the time index need to be supplied:\n\nspde &lt;- inla.spde2.pcmatern(mesh = mesh,\n                              prior.range = c(100, 0.5),\n                              prior.sigma = c(1, 0.5))\n\nt_points = unique(space_time_data$time) #unique time points\n\niset_sp &lt;- inla.spde.make.index(name = \"spatialfield\",\n                                n.spde =  spde$n.spde,\n                                n.group = length(t_points))\n\n# projection matrix using the coordinates of the data and time index\nA_sp &lt;- inla.spde.make.A(mesh = mesh,\n                         loc = st_coordinates(space_time_data),\n                         group = space_time_data$time)\n\nWe can build the stack in a similar fashion to the one in Section 1.1.\n\nstk &lt;- inla.stack(data=list(Ycounts = space_time_data$y,\n                            Ncounts = space_time_data$nvisits,\n                            det_cov = space_time_data$g_s,\n                            Int_det = 1),\n                  A=list(A_sp,1),\n                  effects=list(c(list(Int_occ=1), #the Intercept\n                                 iset_sp),  #the spatial index\n                               #the covariates\n                               list(time = space_time_data$time,\n                                    location = space_time_data$site,\n                                    group_xs = space_time_data$group_xs)),\n                  tag='spat')\n\nNext we specify the prior for the temporal autoregressive parameter and the model formula:\n\n# PC prior for the temporal autocorrelation\nh.spec &lt;- list(rho = list(prior = 'pc.cor0', param = c(0.5, 0.3)))\n\n# extract unique values of the binned covariate\nval_xs = sort(unique(xx))\n\nformula_spat &lt;- inla.mdata(cbind(Ycounts,Ncounts),\n                         Int_det, det_cov) ~ -1 +\n  Int_occ +\n  f(group_xs, model = \"rw2\", values = val_xs)  +\n  f(spatialfield,\n    model=spde,\n    group = spatialfield.group,\n    control.group = list(model = 'ar1',hyper = h.spec))\n\n\n\n\n\n\n\nNote\n\n\n\nNotice that we have used the values argument when defining the rw2 effect to specify the values of the binned covariate at which we will like to do predictions (i.e., over the whole domain). Otherwise, the model would only look at the values of the binned covariate available in the data input.\n\n\nNext we run the model:\n\nCodemodel_spat &lt;- inla(formula_spat, #the formula\n                   data=inla.stack.data(stk),  #the data stack\n                   family= '0binomialS',   #which family the data comes from\n                   control.fixed =  list(prec = 1, prec.intercept = 1),\n                                     control.predictor=list(A=inla.stack.A(stk),\n                                                            compute=TRUE),\n                   #compute = TRUE gives you the marginals of the linear predictor\n                   control.compute = list(dic = TRUE, waic = TRUE,config = TRUE),\n                   #model diagnostics and config = TRUE gives you the GMRF\n                   verbose = F,\n                   control.family = list(control.link = list(model = \"logit\"),\n                                         link.simple = \"logit\",\n                                    hyper = list(beta1 = list(param = c(0,1/3),\n                                                              initial = 0),\n                                                 beta2 = list(param = c(0,1/3)),\n                                                 beta3 = list(param = c(0,1/3)),\n                                                 beta4 = list(param = c(0,1/3)),\n                                                 beta5 = list(param = c(0,1/3)))))\n\n\nThe posterior summaries (i.e. mean, quantiles, std.dev and mode) of the smooth term \\(f(x)\\) estimated using a RW2 are stored in model_spat$summary.random$group_xs. The estimated smooth term can then be plotted against the true function.\n\n\n\n\nFigure 3: Estimated smooth effect of simulated covariate x.\n\n\n\nModel hyper parameters marginal densities can be accessed through model_spat$marginals.hyperpar, posterior summaries of such are shown in Table 4\n\n\n\n\nTable 4: summary results for the space-time occupancy model detection and Matérn covariance matrix parameters.\n\npar\ntrue\nmean\nquant0.025\nquant0.975\n\n\n\n\\(\\alpha_0\\)\n-0.85\n-0.75\n-0.86\n-0.64\n\n\n\\(\\alpha_1\\)\n-1.50\n-1.40\n-1.52\n-1.28\n\n\npractical range\n100.00\n91.54\n53.10\n147.07\n\n\n\\(\\sigma\\)\n1.00\n0.68\n0.53\n0.84\n\n\n\\(\\rho\\)\n0.65\n0.47\n0.08\n0.75"
  },
  {
    "objectID": "index.html#spatial-predictions",
    "href": "index.html#spatial-predictions",
    "title": "Fitting Occupancy models with R-INLA",
    "section": "\n2.2 Spatial predictions",
    "text": "2.2 Spatial predictions\nIn order to do predictions over space and time, we will need the prediction data set we created before, which contains the components used to fit the model. First, the projection matrix A is computed (this will be used for evaluating the model posterior samples of the Gaussian field in the next step).\n\nA_spat = inla.spde.make.A(mesh= mesh, loc = cbind(pred_df$x, pred_df$y),\n                        group = pred_df$time)\n\nThen, posterior samples of the model will be drawn using the inla.posterior.sample() function. A function of the generated samples can be computed using the inla.posterior.sample.eval() function. To do so, we defined a function func_spat() to evaluate the linear predictor components on the posterior samples of the model.\n\nsamples_spat = inla.posterior.sample(1000, model_spat)\n\nfunc_spat = function(...)\n{\n  aa = -(Int_occ + group_xs[as.numeric(as.factor(pred_df$group_xs))] +\n           (A_spat %*% spatialfield)[,1]\n  )\n  aa\n}\n\neval_samples = inla.posterior.sample.eval(func_spat, samples_spat)\n\nSummaries of the posterior samples can then be appended to de prediction data frame for visualization (e.g., mean occupancy probabilities, linear predictor posterior mean, std. dev, difference in quantiles, etc.)\n\nCodeocc_probs = inla.link.logit(eval_samples, inverse = T)\n\npred_df_results = pred_df %&gt;%\n  mutate(eta_sd = apply(eval_samples,1,sd),\n         eta_mu = apply(eval_samples,1,mean),\n         psi_mu = apply(occ_probs,1,mean),\n         quant_range = apply(eval_samples,1,\n                             function(x){quantile(x,0.975)-quantile(x,0.025)})) %&gt;%\n  mutate(time = paste('time',time,sep=' '))\n\n\n\n\n\n\nFigure 4: Estimated mean occupancy probabilities from the space time occupancy model.\n\n\n\nWe can compare these results against the true simulated values previously stored in:\n\ntrue_psi&lt;- terra::rast('raster data/spatsat_occ_probs.tif')\n\n\n\n\n\nFigure 5: True occupancy probabilities simulated from a spatiotemporal Gaussian field with Ar1 component."
  },
  {
    "objectID": "index.html#continuous-space-varying-trend",
    "href": "index.html#continuous-space-varying-trend",
    "title": "Fitting Occupancy models with R-INLA",
    "section": "\n3.1 Continuous space-varying trend",
    "text": "3.1 Continuous space-varying trend\nIn this section we will fit the following SVC occupancy model:\n\\[\\begin{align}\nz_{it} &\\sim \\mathrm{Bernoulli}(\\psi_{it}) \\nonumber \\\\\n\\mathrm{logit}(\\psi_{it}) &= \\beta_0 + \\beta_{1}(i) t + \\omega(i)\\nonumber \\\\\ny_{it}|z_{it} &\\sim \\mathrm{Binomial}(K_i,z_{it} \\times p_i)\\nonumber\\\\\n\\mathrm{logit}(p_{i}) &= \\alpha_0 + \\alpha_1 \\mbox{g}_{i},\n\\label{eq:occ_model3}\n\\end{align}\\]\nwhere the logit-scaled occupancy probabilities at locations \\(i\\) on time \\(t\\) are modeled with a continuous-space varying trend \\(\\beta_{1}(i)\\) , a fixed intercept \\(\\beta_{0}\\) (although a spatially varying intercept \\(\\beta_{0}(i)\\) could be easily fitted as well), and \\(\\omega(i)\\), a Gaussian random field with Matérn covariance function. The detection probabilities and observed occurrences are modeled in the same way as before. As before, the data is structured in a “long” format for its use in INLA.\n\nCodesvc_data &lt;- read.csv(\"Occ_data_3.csv\")\ng_covariate &lt;- terra::rast('raster data/g_covariat.tif')\n\n# Convert to sf\nsvc_data &lt;- svc_data %&gt;%\n  st_as_sf(coords = c('x.loc','y.loc')) %&gt;%\n   rename_with(~ str_remove(., \"\\\\.\"), everything())\n\n\nsvc_data &lt;- svc_data %&gt;%\n  dplyr::select(-cellid) %&gt;%\n        mutate(site = 1:nrow(svc_data),\n               terra::extract(g_covariate,st_coordinates(svc_data)))%&gt;%\n        pivot_longer(cols = starts_with(c(\"n\",\"y\")),\n                     cols_vary = \"slowest\",\n                     names_to = c(\".value\", \"time\"),\n                     names_pattern = \"(.*)(.)\") %&gt;%\n        mutate(nvisits = if_else(is.na(nvisits),0,nvisits),\n               time = as.numeric(time),\n               scale_time = c(scale(time))) %&gt;%\n  dplyr::filter(nvisits &gt; 0) # remove locations that were not visited\n\n\n\n\n\nFirst 6 entries of the occupancy SVC data \n\ngeometry\nsite\ng_s\ntime\nnvisits\ny\nscale_time\n\n\n\nPOINT (4.5 1.5)\n1\n-0.6723235\n1\n5\n1\n-1.414143\n\n\nPOINT (13.5 1.5)\n2\n-0.9056783\n1\n5\n0\n-1.414143\n\n\nPOINT (19.5 1.5)\n4\n-1.1154522\n1\n1\n0\n-1.414143\n\n\nPOINT (25.5 1.5)\n5\n-1.2286578\n1\n1\n1\n-1.414143\n\n\nPOINT (67.5 1.5)\n6\n-0.5804850\n1\n5\n2\n-1.414143\n\n\nPOINT (91.5 1.5)\n7\n0.3230207\n1\n3\n0\n-1.414143\n\n\n\n\n\n\n\n Download data as xlsx\n\n\nFirst, the SPDE model is defined by using PC-priors for the model parameters. Note that two sets of indexes need to be created for (i) the spatial field and (ii) the spatio-temporal component.\n\nspde &lt;- inla.spde2.pcmatern(mesh = mesh,\n                              prior.range = c(100, 0.5),\n                              prior.sigma = c(1, 0.5))\n\niset_sp1 &lt;- inla.spde.make.index(name = \"i1\",\n                                 n.spde =  spde$n.spde)\niset_sp2 &lt;- inla.spde.make.index(name = \"i2\",\n                                 n.spde =  spde$n.spde)\n\nFor the Spatial field \\(\\omega(i)\\), the projector matrix A mapping the model domain to the data locations is computed. As for the space-varying trend, this is represented as the Kronecker product of the projector matrix and the covariate vector, i.e., \\((\\mathbf{A}\\otimes (\\mathbf{x1})^T))\\beta_1\\) . Such computation is done internally within the inla.spde.make.A() function when the covariate vector gets passed on to the weights argument (in this case, the scaled-time covariate).\n\nA_sp1 &lt;- inla.spde.make.A(mesh = mesh,\n                         loc = st_coordinates(svc_data))\n#space-time projector matrix\nA_sp2 &lt;- inla.spde.make.A(mesh = mesh,\n                          loc = st_coordinates(svc_data),\n                          weights = svc_data$scale_time)\n\nFor building the stack both projector matrices and indexes must be specified.\n\nstk &lt;- inla.stack(data=list(Ycounts = svc_data$y,\n                            Ncounts = svc_data$nvisits,\n                            det_cov= svc_data$g_s,\n                            Int_det = 1),\n                  A=list(A_sp1,A_sp2,1),\n                  effects=list(iset_sp1,\n                               iset_sp2,\n                               data.frame(Int_occ = 1,\n                                    scale_time = svc_data$scale_time,\n                                    time = svc_data$time)),\n                  tag='SVC')\n\nThe model formula include both spatial spde models, which is then passed on to the inla function.\n\nCodeformula_svc = inla.mdata(cbind(Ycounts,Ncounts),Int_det,det_cov) ~\n  -1 + Int_occ +\n  f(i1, model=spde)  +\n  f(i2, model=spde)\n\nmodel_svc &lt;- inla(formula_svc, #the formula\n              data=inla.stack.data(stk),\n              family= '0binomialS',\n              control.fixed =  list(prec = 1, prec.intercept = 1),\n              control.predictor=list(A=inla.stack.A(stk),\n                                     compute=TRUE),\n              control.compute = list(dic = TRUE, waic = TRUE,\n                                     config = TRUE),\n              # verbose = TRUE,\n              control.inla = list(int.strategy = \"eb\"),\n              control.family = list(control.link = list(model = \"logit\"),\n                                    link.simple = \"logit\",\n                                    hyper = list(beta1 = list(param = c(0,1/3),\n                                                              initial = 0),\n                                                 beta2 = list(param = c(0,1/3),\n                                                              initial = 0),\n                                                 beta3 = list(param  = c(0,1/3),\n                                                              initial= 0),\n                                                 beta4 = list(param  = c(0,1/3),\n                                                              initial= 1))))"
  },
  {
    "objectID": "index.html#visualize-space-varying-trend",
    "href": "index.html#visualize-space-varying-trend",
    "title": "Fitting Occupancy models with R-INLA",
    "section": "\n3.2 Visualize space-varying trend",
    "text": "3.2 Visualize space-varying trend\nTo plot the predicted spatial trend a fine grid covering the spatial domain must be created. We can use sf::st_make_grid() function to do this.\n\nCodeprojection_grid &lt;- st_make_grid(boundary_sf,cellsize = c(3,3)) %&gt;%\n  st_cast(\"MULTIPOLYGON\") %&gt;%\n  st_sf()\n\n\n\n\n\n\nPrediction grid for the SVC model\n\n\n\nOnce the prediction grid is created, a projector matrix A_pred is computed based on the locations of the grid. Posterior samples of the model are drawn, and the projector matrix is used to evaluate the spatio-temporal trend on the samples.\n\n# projector matrix\nA_pred = inla.spde.make.A(mesh, st_coordinates(projection_grid))\n# samples\nsamples = inla.posterior.sample(1000, model_svc)\n# evaluate the spatial temporal trend\nsvc_eval = inla.posterior.sample.eval(function(x) -(A_pred %*% i2)[,1],\n                                 samples)\n\nWe can compute the posterior mean, median, quantiles, and also check for significance. This information can be appended into a prediction data frame and converting it to a SpatRaster for visualization.\n\nCodedd = data.frame(x = st_coordinates(projection_grid)[,1],\n                y = st_coordinates(projection_grid)[,2],\n                z = apply(svc_eval,1,mean),\n                q1 = apply(svc_eval,1,quantile,0.025),\n                q2 = apply(svc_eval,1,quantile,0.975)) %&gt;%\n  mutate(check = case_when( q1&gt;=0 & q2&gt;=0 ~1,\n                             q1&lt;0 & q2&lt;0 ~ -1,\n                             q1&lt;0 & q2&gt;0 ~ 0)) %&gt;%\n  terra::rast()\n\n\n\n\n\n\nFigure 6: Estimated spatiotemporal trend for a SVC model\n\n\n\nWe can also compute a the predicted occupancy probabilities at a fixed time point \\(t\\) by evaluating the linear predictor on the posterior samples. We define a function func_svc() to compute the the liner predictor for a given time point.\n\nfunc_svc = function(..., time)\n{\n  fix = Int_occ\n  spat = (A_pred %*% i1)[,1]\n  spat2 = (A_pred %*% i2)[,1] * sort(unique(svc_data$scale_time))[time]\n  return(-(fix + spat + spat2))\n\n}\n\nFor example, for \\(t=5\\) we can compute the posterior mean occupancy probability as follows:\n\nCode# select t= 5\ntime=5\n\n# evaluate the linear predictor on the posterior samples\neta_post = inla.posterior.sample.eval(func_svc, samples, time = 5)\n\ndd2 = data.frame(x = st_coordinates(projection_grid)[,1],\n                y = st_coordinates(projection_grid)[,2],\n                psi =apply(inla.link.logit(eta_post, inverse = T),1,mean)) %&gt;%\n  terra::rast()\n\n\n\n\n\n\nFigure 7: SVC model estimated (left) and simulated (right) occupancy probabilitiesfor time point 5."
  },
  {
    "objectID": "index.html#regional-varying-trend",
    "href": "index.html#regional-varying-trend",
    "title": "Fitting Occupancy models with R-INLA",
    "section": "\n3.3 Regional Varying Trend",
    "text": "3.3 Regional Varying Trend\nNow suppose we are interested in modelling the regional varying trend \\(\\beta_{R_i}\\) for a set of \\(p\\) non-overlapping regions over the spatial domain, i.e. \\(\\mathcal{D} = \\bigcup\\limits_{i=1}^p R_i\\) such that \\(R_i\\bigcap R_j = \\emptyset\\) for each \\(i\\neq j\\). We can discretized the study area into 20 regions as follows:\n\nCodeR_i &lt;- st_make_grid(boundary_sf, cellsize = 90, square = FALSE) %&gt;%\n    st_cast(\"MULTIPOLYGON\") %&gt;%\n  st_sf() %&gt;%\n  mutate(cellid = row_number()) %&gt;%\n  st_crop(boundary_sf) %&gt;%\n  st_collection_extract( \"POLYGON\") %&gt;%\n  mutate(cellid = 1:length(cellid))\n\n\n\n\n\n\nFigure 8: Partition of the spatial domain into 20 non-overlapping Regions.\n\n\n\nThe regional varying trend \\(\\beta_{R_i}\\) in the linear predictor can be vary across the \\(p\\) discrete aerial units through \\(iid\\) random effects, or according to a spatial dependence structure modeled with an areal spatial process. For the latter case, the spatial structure is usually described by neighborhood matrices. The R-package spdep facilitates building a neighbors list based on the defined regions and then generates a weights matrix \\(\\mathbf{W}\\) (e.g. \\(w_{ij} = 1\\) if region \\(i\\) is neighbor of \\(j\\) and zero otherwise) .\n\nlibrary(spdep)\nN.adj &lt;- poly2nb(pl = R_i)\nW.nb&lt;- nb2mat(N.adj, style = \"B\")\n\nNext, we find the region id where each observation lies and append this information to the data set.\n\nsvc_data_R &lt;- svc_data %&gt;% mutate(cellid = unlist(st_intersects(svc_data,R_i)))\n\nThe spatial relationships can be described by one of INLA’s available areal spatial models (see inla.list.models(\"latent\") for a list of the latent models available in INLA). In this example, we will use the Besag-York-Mollié model (BYM) which is an extension to the intrinsic CAR model that contains an i.i.d. model component for the non-spatial heterogeneity, i.e.\n\\[\\begin{align*}\n\\beta_{R_i} &= u_i + v_i \\\\\nu_i|\\mathbf{u}_{-i} &~\\sim N \\left(\\frac{\\sum_j w_{ij}u_j}{\\sum_j w_{ij}},\\frac{1}{\\tau_1\\sum_j w_{ij}}\\right)\\\\\nv_i &\\sim N(0,\\tau_2^{-1})\n\\end{align*}\\]\nThus, slopes are sampled from a normal distribution, where the conditional mean is linked to the average of neighboring cells and a conditional variance proportional to the variance across adjacent cells and inversely proportional to the number of adjacent cells. For fitting this model in INLA we need a spatial index for the spatial field \\(\\omega(i)\\) and projection matrix to map the model domain to the coordinates of the data.\n\niset_sp &lt;- inla.spde.make.index(name = \"spatialfield\",\n                                n.spde =  spde$n.spde)\nA_sp &lt;- inla.spde.make.A(mesh = mesh,\n                         loc = st_coordinates(svc_data_R))\n\nWe also need to supply the region id index from the data as a numerical input in the stack effects list.\n\nstk &lt;- inla.stack(data=list(Ycounts = svc_data_R$y,\n                            Ncounts = svc_data_R$nvisits,\n                            det_cov= svc_data_R$g_s,\n                            Int_det = 1),\n                  A=list(A_sp,1),\n                  effects=list(iset_sp,\n                               data.frame(Int_occ = 1,\n                                    region_id = svc_data_R$cellid,\n                                    scale_time = svc_data_R$scale_time,\n                                    time = svc_data_R$time)),\n                  tag='SVC_R')\n\nTo fit the regional varying trend model with BYM structured spatial effects, the component related to the space-varying coefficient in the model formula must contain:\n\nThe region id (as defined in the data stack)\nThe covariate value (in this case the scaled-time)\nThe CAR model (model =\"bym\")\nThe weight matrix \\(\\mathbf{W}\\)\n\n\nformula_svc_R = inla.mdata(cbind(Ycounts,Ncounts),Int_det,det_cov) ~\n  -1 + Int_occ +\n  f(region_id,scale_time, model = \"bym\", graph = W.nb)  +\n  f(spatialfield,\n    model = spde)\n\nWe will save the inla output as model_svc_R :\n\nCodemodel_svc_R &lt;- inla(formula_svc_R, #the formula\n              data=inla.stack.data(stk),\n              family= '0binomialS',\n              control.fixed =  list(prec = 1, prec.intercept = 1),\n              control.predictor=list(A=inla.stack.A(stk),\n                                     compute=TRUE),\n              control.compute = list(dic = TRUE, waic = TRUE,\n                                     config = TRUE),\n              # verbose = TRUE,\n              control.inla = list(int.strategy = \"eb\"),\n              control.family = list(control.link = list(model = \"logit\"),\n                                    link.simple = \"logit\",\n                                    hyper = list(beta1 = list(param = c(0,1/3),\n                                                              initial = 0),\n                                                 beta2 = list(param = c(0,1/3),\n                                                              initial = 0),\n                                                 beta3 = list(param  = c(0,1/3),\n                                                              initial= 0),\n                                                 beta4 = list(param  = c(0,1/3),\n                                                              initial= 1))))\n\n\nTo visualize the results we can take the prediction grid created for the prediction of the continuous-space varying trend model and index each cell according to the region \\(R_i~\\mbox{for } i = 1,\\ldots,20\\).\n\n# add cellid to prediction grid\nprojection_grid_R &lt;- st_intersection(projection_grid,R_i)\n\n\n\n\n\nFigure 9: Grid for predicting the space-varying trend estimated with the Regional SVC model across 20 non-overlapping regions.\n\n\n\nNext, we compute posterior samples of the model to evaluate the trend for each cell indexed by region \\(R_i\\).\n\n# samples\nsamples = inla.posterior.sample(1000, model_svc_R)\n\n# evaluate the spatial temporal trend\nsvc_eval_R = inla.posterior.sample.eval(function(x)\n  -(region_id[projection_grid_R$cellid]), samples)\n\nFinally, we can compute posterior quantities (i.e. the mean, quantiles, etc) and check for significance. This information can be appended directly into the prediction grid which can be then be rasterized using the stars R-package for visualization purposes.\n\n# append to prediction grid\nprojection_grid_R =projection_grid_R %&gt;%\n  mutate( z = apply(svc_eval_R,1,mean),\n          q1 = apply(svc_eval_R,1,quantile,0.025),\n          q2 = apply(svc_eval_R,1,quantile,0.975),\n          check = case_when( q1&gt;=0 & q2&gt;=0 ~1,\n                             q1&lt;0 & q2&lt;0 ~ -1,\n                             q1&lt;0 & q2&gt;0 ~ 0))\n\n# Rasterize\nregional_trend &lt;-stars::st_rasterize(projection_grid_R)\n\n\n\n\n\nFigure 10: Estimated regional varying trend from a SVC model."
  }
]