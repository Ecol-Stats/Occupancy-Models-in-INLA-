[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Fitting Occupancy models with R-INLA",
    "section": "",
    "text": "This section describes the steps to fit occupancy models in R-INLA using simulated data (simulation details can be found in the Data Simulation tab)."
  },
  {
    "objectID": "index.html#sec-setup1",
    "href": "index.html#sec-setup1",
    "title": "Fitting Occupancy models with R-INLA",
    "section": "\n1.1 Set up",
    "text": "1.1 Set up\nWe first load the data and prepare it in the format that is required by R-INLA.\n\nCodelibrary(INLA)\nlibrary(inlabru)\nlibrary(fmesher)\nlibrary(tidyverse)\nlibrary(sf)\nlibrary(terra)\nlibrary(dplyr)\n\n\nocc_data &lt;- read.csv(\"Occ_data_1.csv\")\nx_covariate &lt;- terra::rast('raster data/x_covariat.tif')\ng_covariate &lt;- terra::rast('raster data/g_covariat.tif')\n\n# Extract the covariate values\n\n# Convert to sf and evaluate site-level covariates at each cell \n\nSSOM_sf = occ_data %&gt;%\n  st_as_sf(coords = c('x.loc','y.loc'))  \n\nSSOM_sf = SSOM_sf %&gt;%\n  dplyr::select(-cellid) %&gt;% \n        mutate(terra::extract(x_covariate,st_coordinates(SSOM_sf)),\n               terra::extract(g_covariate,st_coordinates(SSOM_sf)))\n\n\n# append coordinates and remove geometry attributes\n\nSSOM = SSOM_sf %&gt;% \n    mutate(x.loc= st_coordinates(SSOM_sf)[,1],\n           y.loc= st_coordinates(SSOM_sf)[,2]) %&gt;% \n    st_drop_geometry()\n\n\n\n\n\nTable 1: First 6 entries of the occupancy data\n\n\n\n\ny.1\ny.2\ny.3\ng2.1\ng2.2\ng2.3\nx_s\ng_s\nx.loc\ny.loc\n\n\n\n0\n0\n0\n0.57\n0.39\n-0.25\n-0.09\n0.36\n4.5\n1.5\n\n\n1\n1\n1\n-0.19\n-0.71\n0.45\n-0.10\n0.61\n13.5\n1.5\n\n\n1\n1\n1\n-0.37\n0.94\n-0.11\n-0.32\n0.66\n16.5\n1.5\n\n\n0\n1\n1\n0.31\n0.56\n0.76\n-0.23\n0.79\n19.5\n1.5\n\n\n1\n1\n1\n0.61\n-0.42\n0.11\n-0.07\n1.16\n25.5\n1.5\n\n\n1\n1\n1\n0.13\n-0.96\n-0.97\n-1.50\n0.94\n67.5\n1.5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Download data as xlsx\n\n\n\n Download g raster file\n\n\n\n\n Download x raster file\n\n\n\n\nTo better understand the data structures that are used by R-INLA, we will split the data as follows:\n\n\nThe observed presence/absence matrix \\(Y_{M\\times K}\\) with binary entries \\(y_{ij}\\) for \\(i \\in 1,\\ldots M\\) sites and \\(j \\in 1,\\ldots,K\\) maximum number of visits.\n\nY_mat &lt;- SSOM %&gt;% dplyr::select(num_range(\"y.\",1:3)) %&gt;% as.matrix()\n\n\n\nA matrix for the spatial coordinates of the sites\n\nXY_coords &lt;- SSOM %&gt;% dplyr::select(c(x.loc, y.loc)) %&gt;% as.matrix()\n\n\n\nThe occupancy covariates for the state/occupancy process.\n\nX_occ &lt;- SSOM %&gt;% dplyr::select(x_s) \n\n\n\nThe detection covariates for the observational process declared as a matrix \\(G_{M \\times \\left[ K (P+1)\\right]}\\), where \\(P\\) is the number of detection covariates. Here, the first \\(P+1\\) columns correspond to the intercept (1st column) and the \\(l= 1,\\ldots,P\\) covariates \\(g_{ijl}\\) on the first visit \\(j =1\\) across \\(i = 1,\\ldots,M\\) sites. A new intercept column defines the next \\(l\\) covariates measurements at the second visit \\(j=2\\) , and so on until the \\(K\\)th visit.\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\n\n\nFor constant detection probabilities a \\(G_{M \\times \\left[ K (P+1)\\right]}\\) matrix with \\(g_{ijl} = 1 \\ \\forall\\ (i,j,l)\\) entries must be specified. Likewise if a site-level covariate is to be used, then the values for that covariate must be repeated across the \\(K\\) maximum number of visits. The function inla.Occupancy_detCovbelow helps farmating the detection data as required by R-INLA. It receives as arguments either (i) a \\(G_{ij}\\) matrix for a single covariate input or (ii) a list \\(G^{(l)}_{ij}\\) where the \\(l-\\)th element of the list corresponds to the \\(l-\\)th survey or site level covariate:\n\nCodeinla.Occupancy_detCov &lt;- function(X_det){\n\n  if(class(X_det)==\"list\"){\n    if(length(X_det)&gt;10){\n      warning(\"exceeded number of detection covariates, numerical issues may occur\")\n    }\n\n    if(lapply(X_det, ncol)%&gt;%unlist()%&gt;%unique()%&gt;%length()&gt;2){\n      stop(\"inconsistent number of visits in provided detection covariates\")\n    }\n    if(length(lapply(X_det, nrow) %&gt;% unlist() %&gt;% unique())&gt;1){\n      stop(\"inconsistent number of sites in provided detection covariates\")\n    }\n    K&lt;- lapply(X_det, ncol) %&gt;% unlist() %&gt;% max() # Max num of visits\n    M&lt;- lapply(X_det, nrow) %&gt;% unlist() %&gt;% unique() # Number of sites\n    P &lt;- length(X_det)\n\n    if(lapply(X_det, ncol)%&gt;%unlist()%&gt;%unique()%&gt;%length()==2 & \n       1 %in% lapply(X_det, ncol)%&gt;%unlist()%&gt;%unique()){\n      warning(paste(\"At least one covariate of dimension [\",M,\",1] has been provided, values for this covariate will be repeated over the max numver of visits\",sep=\"\"))\n      for(l in which(lapply(X_det, ncol) %&gt;% unlist() &lt; K)){\n        X_det[[l]] &lt;- do.call(\"cbind\",replicate(K,X_det[[l]]))\n\n      }\n    }\n    covariates &lt;- do.call(\"cbind\", lapply(1:K, function(i) {\n      do.call(\"cbind\", lapply(X_det, function(mat) mat[, i]))\n    }))\n\n  }\n\n  if(is.data.frame(X_det)|is.matrix(X_det)){\n    K&lt;- ncol(X_det)\n    M&lt;- nrow(X_det)\n    P &lt;- 1\n    covariates &lt;- as.matrix(X_det)\n  }\n\n  X_mat &lt;- matrix(NA,nrow=M,ncol=K*(P+1))\n  X_mat[,seq(1,(K*(P+1)),by=(P+1))]&lt;-1 # add Intercept at the begining of each visit-specific covariate matrix\n  X_mat[, which(!(1:(K*(P+1)) %in% seq(1,(K*(P+1)),by=(P+1))))] &lt;- covariates\n  return(X_mat)\n\n}\n\nhill_4P &lt;- function(x,Int_occ,a,b,c){\n  y = Int_occ + (a*x^b)/(c^b + x^b)\n  y\n}\n\n\n\n\n\n\nX_det &lt;- list(\n  SSOM %&gt;% dplyr::select(g_s),\n  SSOM %&gt;% dplyr::select(num_range(\"g2.\",1:3))) %&gt;% \n  inla.Occupancy_detCov()\n\n\n\n\nTable 2: First 6 entries of the detection covariate g as required by R-INLA.\n\n\n\n\n\n\n\nVisit 1\nVisit 2\nVisit 3\n\n\nIntercept\ng1.\ng2,1\n\nIntercept\ng1.\ng2,2\n\nIntercept\ng1.\ng2,3\n\n\n\n\n\n1.00\n0.36\n0.57\n1.00\n0.36\n0.39\n1.00\n0.36\n−0.25\n\n\n1.00\n0.61\n−0.19\n1.00\n0.61\n−0.71\n1.00\n0.61\n0.45\n\n\n1.00\n0.66\n−0.37\n1.00\n0.66\n0.94\n1.00\n0.66\n−0.11\n\n\n1.00\n0.79\n0.31\n1.00\n0.79\n0.56\n1.00\n0.79\n0.76\n\n\n1.00\n1.16\n0.61\n1.00\n1.16\n−0.42\n1.00\n1.16\n0.11\n\n\n1.00\n0.94\n0.13\n1.00\n0.94\n−0.96\n1.00\n0.94\n−0.97\n\n\n\n\n\n\n\n\n\n\n\n\n1.1.1 Constructing the mesh and defining the SPDE\nThe linear predictor can include a variety of random effects such as smooth terms or spatiotemporal components by incorporating Gaussian random fields (GRFs) into models. This is achieved by using the stochastic partial differential equation (SPDE) method introduced by Lindgren, Rue, and Lindström (2011). The SPDE approach relies discretizing the space by defining a mesh that creates an artificial set of neighbours over the study area that allows for the spatial autocorrelation between observation to be calculated. How the mesh is constructed will have an important impact on the inference and predictions we make. Thus, it is important to create a good mesh to ensure results are not sensible to the mesh itself (guidance for creating a mesh can be found in Krainski et al. (2018) section 2.6.3). The inla.spde2.pcmatern() function is used to define the SPDE model. Using the penalized complexity (PC) priors derived in Fuglstad et al. (2018) on the range and marginal standard deviation.\n\nCodeboundary_sf = st_bbox(c(xmin = 0, xmax = 300, ymax = 0, ymin = 300)) %&gt;%\n\n  st_as_sfc() %&gt;% st_as_sf()\n\nmesh = fm_mesh_2d(loc.domain = st_coordinates(boundary_sf)[,1:2],\n\n                    offset = c(-0.1, -.2),\n\n                    max.edge = c(15, 30))\n\nmatern &lt;- inla.spde2.pcmatern(mesh,\n\n                              prior.range = c(100, 0.5),\n\n                              prior.sigma = c(1, 0.5))\n\n\n\n\n\n\n\n\n\n\nTo define a spatial model we create the projector A matrix that maps the spatial Gaussian random field to the locations of the observed data and organize it along with the data, indeces and covariates.\nTypically, this is done through the inla.stack() function (see Krainski et al. (2018) sections 2.3.2 and 2.3.3 for more details). However, recent developments in R-INLA allows the mapping matrix A to be called directly in the model formula to facilitate the specification of spatial models through the A.local argument.\n\n\n\n\n\n\nCaution\n\n\n\nHere, we present how these two approaches can be implemented. However, since the later feature is still under development, we encourage practicioners to use the inla.stack() function for now.\n\n\n\n\nUsing inla.stack()\nUsing A.local\n\n\n\nWhen building the stack we need to supply three main arguments:\n\nList containing the data and the detection covariates matrix,\nList of projector matrices (in this case the projector matrix A for the spatial field and a matrix that maps the covariate and the response)\nList of effects including (i) the occupancy intercept, (ii) the index set for the spatial field (that takes into account the number of mesh points in the SPDE ) and (iii) a list of the site-level covariate(s) for the state process of interest.\n\n\n# projector matrix A\n\nA_sp &lt;- inla.spde.make.A(mesh = mesh,loc = XY_coords)\n\n# index set\n\niset_sp &lt;- inla.spde.make.index(name = \"spatial_field\", matern$n.spde)\n\n\n# build the stack\nstk &lt;- inla.stack(data=list(Y = Y_mat,  # observed occurrences\n                            X = X_det), # detection covariate\n                     A=list(A_sp,1),        # project matrices\n                  effects=list(iset_sp,     # the spatial index\n                     data.frame(Int_occ=1,  # Occ Intercept\n                     occ_cov = X_occ$x_s)), # covariate x\n                  #this is a quick name so yo can call upon easily\n                  tag='ssom')\n\nNow we define the model components (left hand side -observational model components; right hand side - state process components) and fit the model using the inla function:\n\nformula_ssom &lt;- inla.mdata(Y,X) ~  -1 +  Int_occ +  \n  occ_cov +  f(spatial_field, model=matern)\n\nmodel_ssom &lt;- inla(formula_ssom, # model formula\n\n                 data=inla.stack.data(stk), # data stack\n\n                 family= 'occupancy', # model likelihood\n\n                 # priors\n\n                 control.fixed =  list(prec = 1/2.72, prec.intercept = 1/2.72),\n\n                 # matrix of predictors\n\n                 control.predictor=list(A=inla.stack.A(stk),compute=TRUE),\n\n                 # compute WAIC and DIC\n\n                 control.compute = list(dic = TRUE, waic = TRUE, config = TRUE),\n\n                 verbose = FALSE,\n\n                 # choose link functions for:\n\n                 # (i) the state process (control.link)\n\n                 # (ii) the observation process (link.simple)\n\n                 control.family = list(control.link = list(model = \"logit\"),\n\n                                       link.simple = \"logit\",\n\n                 # priors for hyperparameters\n\n                 hyper = list(\n                  # Detection intercept prior \n                   beta1 = list(param = c(0,1), initial = -1),\n                  # Covariate 1 effect prior \n                   beta2 = list(param = c(0,1/2.72)),\n                  # Covariate 2 effect prior \n                   beta3 = list(param = c(0,1/2.72))\n\n                 )\n\n                 ))\n\n\n\n\n\n\n\nNote\n\n\n\nWe explicitly removed the intercept in the occupancy formula and included it as covariates in the list of effects. Then, the covariate terms (which are now included in the projector matrix) are passed on to inla() through the control.predictor argument. Priors for the detection parameters are provided as a list in the hyper option of the control.family argument. The order of these priors matches the order of the detection covariates in the matrix supplied in the inla.mdata argument.\n\n\n\n\nCompute the mapping matrix A using the inla.spde.make.Afunction which receives as arguments the mesh and the data coordinates. Then, the occupancy data need to be changed slightly by explicitly adding (1) the intercept term as a column of 1’s, and (2) an empty vector for spatial field (as this will be passed on directly to the f() function in inla).\n\nA_sp &lt;- inla.spde.make.A(mesh = mesh,loc = XY_coords)\n\nX_occ2 &lt;- X_occ %&gt;% \n  mutate(Int_occ =1,\n         spatial_field = rep(NA,nrow(X_occ))) %&gt;%\n  rename(occ_cov=x_s)\n\nThen, we can supply the data as a list containing the following elements:\n\nA list of the occupancy covariates including the intercept (note that the names of the elements of this list are the ones that should be specified in the model formula).\nDetection/non-detection data \\(Y_{M\\times K}\\).\nDetection covariates matrix \\(G_{M \\times \\left[ K (P+1)\\right]}\\).\n\n\nCodedata_list = as.list(X_occ2)\ndata_list$Y = Y_mat\ndata_list$X = X_det\n\n\nNow, we define the model components (left hand side -observational model components; right hand side - state process components) and fit the model using the inla function:\n\nformula_ssom &lt;- inla.mdata(Y,X) ~  -1 + Int_occ +  \n  occ_cov +  f(spatial_field, model=matern,  A.local = A_sp)\n\nmodel_ssom &lt;- inla(formula_ssom,    # model formula\n                 data= data_list,        # data \n                 family= 'occupancy', # model likelihood\n\n                 # priors\n                 control.fixed =  list(prec = 1/2.72, prec.intercept = 1/2.72),\n\n                 # compute WAIC and DIC\n                 control.compute = list(dic = TRUE, waic = TRUE, config = TRUE),\n                 verbose = FALSE,\n\n                 # choose link functions for:\n\n                 # (i) the state process (control.link)\n                 # (ii) the observation process (link.simple)\n                 control.family = list(control.link = list(model = \"logit\"),\n                                        link.simple = \"logit\",\n\n                 # priors for hyperparameters\n                 hyper = list(\n                   # Detection intercept prior \n                   beta1 = list(param = c(0,1), initial = -1),\n                   # Covariate 1 effect prior\n                   beta2 = list(param = c(0,1/2.72)),\n                   # Covariate 2 effect prior \n                   beta3 = list(param = c(0,1/2.72))\n                 )\n                 ))\n\nPriors for the detection parameters are provided as a list in the hyper option of the control.family argument. The order of these priors matches the order of the detection covariates in the matrix supplied in the inla.mdata argument."
  },
  {
    "objectID": "index.html#results",
    "href": "index.html#results",
    "title": "Fitting Occupancy models with R-INLA",
    "section": "\n1.2 Results",
    "text": "1.2 Results\nThe summary of the fixed effect, namely \\(\\beta_0\\) and \\(\\beta_1\\) can be retrieved from model_ssom$summary.fixed while detection parameters \\(\\alpha_0\\) and \\(\\alpha_1\\) are contained, along with the range and standard deviation, in model_ssom$summary.hyperpar.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSummary results from the fitted SSOM are shown in Table 3 and posterior densities on Figure 1.\n\n\n\nTable 3: summary results for the occupancy model parameters and their corresponding true values.\n\n\n\n\npar\ntrue\nmean\nquant0.025\nquant0.975\n\n\n\n\\(\\beta_0\\)\n-0.85\n-1.16\n-2.49\n0.53\n\n\n\\(\\beta_1\\)\n1.50\n1.58\n1.24\n1.93\n\n\n\\(\\alpha_0\\)\n0.41\n0.40\n0.25\n0.55\n\n\n\\(\\alpha_1\\)\n1.00\n1.04\n0.91\n1.17\n\n\n\\(\\alpha_2\\)\n0.50\n0.53\n0.32\n0.74\n\n\n\\(\\rho\\)\n100.00\n193.27\n81.57\n406.64\n\n\n\\(\\sigma\\)\n1.00\n1.49\n0.87\n2.43\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: Posterior densities of the fixed effect parameters of a simple spatial occupancy model fitted with R-INLA.The vertical solid line represent the true value of the parameter."
  },
  {
    "objectID": "index.html#model-comparison-through-cross-validation",
    "href": "index.html#model-comparison-through-cross-validation",
    "title": "Fitting Occupancy models with R-INLA",
    "section": "\n1.3 Model comparison through cross-validation",
    "text": "1.3 Model comparison through cross-validation\nNext we introduce how to implement modelling comparison using leave-out group cross validation (LGOCV). The underlying idea is that of a Bayesian prediction setting where we approximate the posterior predictive density \\(\\pi(\\mathbf{\\tilde{Y}}|\\mathbf{y})\\) defined as the integral over the posterior distribution of the parameters, i.e.\n\\[\n\\pi(\\mathbf{\\tilde{Y}}|\\mathbf{y}) = \\int_\\theta \\pi(\\mathbf{\\tilde{Y}}|\\theta,\\mathbf{y}) \\pi(\\theta|\\mathbf{y})d\\theta\n\\]\nthe LGOCV selects a fixed test point \\(i\\) and remove a certain group of data \\(\\mathbb{I}_i\\) according to a specific prediction task. Thus, we are interested in the posterior predictive density\n\\[\n\\pi(Y_i|\\mathbf{y}{-\\mathcal{I}i}) = \\int\\theta \\pi(Y_i|\\theta,\\mathbf{y}{-\\mathbb{I}_i}) \\pi(\\theta|\\mathbf{y})d\\theta\n\\]\nWith this, a point estimate \\(\\tilde{Y_i}\\) can be computed based on \\(\\pi(Y_i|\\mathbf{y}_{-\\mathbb{I}_i})\\) and the predictive performance be assessed using an appropriate scoring function \\(U(\\tilde{Y}_i,Y_i)\\), for example, the log-score function\n\\[\n\\frac{1}{n}\\sum_{i=1}^n \\mathrm{log}~ \\pi(\\mathbf{\\tilde{y}}|\\mathbf{y}).\n\\]\nIn this example, the LGOCV strategy will be used to compare the previous fitted spatially explicit occupancy model against a simple model that only considers a site iid random effect (note that since no structured spatial effect is being included, the data can be passed on to inla() as a list without the need for a stack).\n\nSSOM_simple = as.list(data.frame(site= 1:nrow(SSOM),Int_occ = 1))\nSSOM_simple$Y &lt;- Y_mat\nSSOM_simple$X &lt;- X_det\n\nformula_simple = inla.mdata(Y,X)  ~ f(site, model =  \"iid\")\n\nmodel_simple &lt;- inla(formula_simple, data=SSOM_simple,\n                     family= 'occupancy',verbose = FALSE,\n               control.compute = list( config = TRUE,dic  = T, waic = T),\n               control.fixed = list(prec.intercept = 1/2.72,prec = 1/2.72),\n               control.family = list(control.link = list(model = \"logit\"),\n                                     link.simple = \"logit\",\n                                     hyper = list(beta1 = list(param = c(0,1),\n                                                           initial = 0),\n                                                  beta2 = list(param = c(0,1)),\n                                                  beta3 = list(param = c(0,1))\n                                                  )))\n\nIn this example the leave-out group \\(\\mathbb{I}_i\\) is manually defined for the \\(i\\)th row of the data based on a buffer of size \\(b=25\\) centered at each data point (we will use the sf object created before):\n\n# create buffer of size 25 centred at each site\nbuffer &lt;- st_buffer(SSOM_sf, dist = 25)\n\n# Lists of the indexes of the leave-out-group for each observation i\nIi &lt;- st_intersects(SSOM_sf,buffer)\n\n\n\n\n\n\n\n\nFigure 2: Example of the CV strategy for the 500th testing point.\n\n\n\n\nThe LGOCV is used to evaluate the predictive performance of each model and the log-scores are computed as shown in Table 4.\n\nlgocv_ssom = inla.group.cv(result = model_ssom, groups= Ii)\nlgocv_simple = inla.group.cv(result = model_simple, group.cv = lgocv_ssom)\n\nlog_score_ssom &lt;- mean(log(lgocv_ssom$cv),na.rm=T)\nlog_score_simple &lt;-mean(log(lgocv_simple$cv),na.rm=T)\n\n\n\n\nTable 4: Leave group out CV log scores of a spatially explicit occupancy model and a simple occupancy model with a site iid random effect.\n\n\n\n\n\n\n\n\n\n\n\nLog-Score LGOCV\n\n\nContinuous spatial\nGaussian field\nSite iid\nrandom effect\n\n\n\n−0.70\n−0.82"
  },
  {
    "objectID": "index.html#set-up",
    "href": "index.html#set-up",
    "title": "Fitting Occupancy models with R-INLA",
    "section": "\n2.1 Set up",
    "text": "2.1 Set up\nFirst, we need the data to have the correct structure with columns representing the observed occurrences, number of visits, the cell/site id, the site-level covariates, and the time points. An additional filtering is made to remove the locations that were not visited in a given time point.\n\nCode# read the data\nspace_time_data &lt;- read.csv(\"Occ_data_2.csv\")\n# raster data\nx_covariate &lt;- terra::rast('raster data/x_covariat.tif')\n# function for structuring detection covariates\nsource(\"detection_covariates_function.R\")\n\n# Convert to sf\nspace_time_data_sf &lt;- space_time_data %&gt;%\n  st_as_sf(coords = c('x.loc','y.loc')) \n\n# evaluate covariate at each cell\n\nspace_time_data_sf &lt;- space_time_data_sf %&gt;%\n        mutate(site = as.factor(cellid),\n               terra::extract(x_covariate,st_coordinates(space_time_data_sf)))\n\n# (optional) if an i.i.d random effect by sites is to be used.\nlevels(space_time_data_sf$site) &lt;- 1:nlevels(space_time_data_sf$site) \n\nspat_data  = space_time_data_sf %&gt;% \n  dplyr::select(-cellid) %&gt;%\n  mutate(x.loc= st_coordinates(space_time_data_sf)[,1],\n         y.loc= st_coordinates(space_time_data_sf)[,2]) %&gt;% st_drop_geometry()\n\n\n\n\n\nFirst 6 entries of the occupancy spatiotemporal data\n\ny1\ny2\ny3\ng1\ng2\ng3\ntime\nsite\nx_s\nx.loc\ny.loc\n\n\n\n1\n0\nNA\n0.50\n-0.16\n-0.81\n1\n1\n-0.09\n4.5\n1.5\n\n\n1\nNA\nNA\n-0.90\n-0.89\n0.32\n2\n1\n-0.09\n4.5\n1.5\n\n\n0\n0\n0\n-0.97\n0.75\n0.94\n3\n1\n-0.09\n4.5\n1.5\n\n\n0\n0\n0\n0.06\n-0.69\n0.31\n4\n1\n-0.09\n4.5\n1.5\n\n\n0\n0\n0\n-0.92\n-0.06\n0.28\n5\n1\n-0.09\n4.5\n1.5\n\n\nNA\n1\n0\n0.70\n-0.63\n0.57\n1\n2\n-0.10\n13.5\n1.5\n\n\n\n\n\n\n\n Download data as xlsx\n\n\nFor the estimation of the smooth effect, we can reduce the number of knots used in the estimation process by grouping the covariate \\(x\\) values into equal length intervals with the inla.group() function and appending these grouped values to the data.\n\n\n\n\n\n\nImportant\n\n\n\nAt this point we will also create a data frame for prediction, containing the values of the binned covariates \\(x\\) for every time time point in the data.\n\n\n\nnT &lt;- length(spat_data$time %&gt;% unique) # number of time points\nncells &lt;- length(values(x_covariate$x_s)) # number of cells in the whole area\n\n# scale and centre the covariate value in the data input\n\nspat_data &lt;- spat_data %&gt;%\n  mutate(scale_x_s = scale(x_s)  %&gt;% c())\n\n# prediction data frame\n\npred_df = data.frame(x = rep(crds(x_covariate)[,1],nT),\n                     y = rep(crds(x_covariate)[,2],nT),\n                     x_s = rep(as.vector(scale(values(x_covariate$x_s))),nT),\n                     time = rep(c(1:nT), each= ncells))\n\n# binned covariate values.\n\nxx = inla.group(c(spat_data$x_s, pred_df$x_s),\n                n = 35)\n\n# append grouped covariate values to the input and prediction data sets\n\nspat_data$group_xs = xx[1:dim(spat_data)[1]]\npred_df$group_xs = xx[-c(1:dim(spat_data)[1])]"
  },
  {
    "objectID": "index.html#fitting-a-space-time-occupancy-model-in-inla",
    "href": "index.html#fitting-a-space-time-occupancy-model-in-inla",
    "title": "Fitting Occupancy models with R-INLA",
    "section": "\n2.2 Fitting a space-time Occupancy model in INLA\n",
    "text": "2.2 Fitting a space-time Occupancy model in INLA\n\nTo fit a separable space time model, the SPDE needs to be defined first:\n\nboundary_sf = st_bbox(c(xmin = 0, xmax = 300, ymax = 0, ymin = 300)) %&gt;%\n  st_as_sfc() %&gt;% st_as_sf()\n\nmesh = fm_mesh_2d(loc.domain = st_coordinates(boundary_sf)[,1:2],\n                    offset = c(-0.1, -.2),\n                    max.edge = c(15, 30))\n\nspde &lt;- inla.spde2.pcmatern(mesh = mesh,\n                              prior.range = c(100, 0.5),\n                              prior.sigma = c(1, 0.5))\n\nFor building the projection matrix A, the coordinates and the time index need to be supplied. Again, we showcase how can this be done by either (1) constructing a data stack with the inla.stack() function or (2) by providing the projection matrix in the A.local argument.\n\n\nThe inla.stack() option (recommended)\nA.local argument (testing version)\n\n\n\n\nTo fit a separable space time model, the index set need to be defined (see Krainski et al. (2018) Section 7.1.2 for further reference on building the stack for a separable space time model in INLA). We can build the stack in a similar fashion to the one in Section 1.1.\n\n# unique time points\nt_points = unique(spat_data$time) \n\n# index set; \"spatialfield\" is the name used in the model formula\niset_sp &lt;- inla.spde.make.index(name = \"spatialfield\", \n                                n.spde =  spde$n.spde,\n                                n.group = length(t_points))\n\n# projection matrix using the coordinates of the data and time index\n\nA_sp &lt;- inla.spde.make.A(mesh = mesh,\n                         loc = as.matrix(spat_data[,c(\"x.loc\",\"y.loc\")]),\n                         group = spat_data$time)\n\nY_mat &lt;- spat_data %&gt;%\n  dplyr::select(num_range(\"y\",1:3)) %&gt;% \n  as.matrix()\nX_det &lt;- spat_data %&gt;%\n  dplyr::select(num_range(\"g\",1:3)) %&gt;% \n  inla.Occupancy_detCov()\nX_cov &lt;- spat_data %&gt;%\n  dplyr::select(c(time,site,group_xs))\n\nstk &lt;- inla.stack(data=list(Y = Y_mat,  X = X_det),\n                  A=list(A_sp,1),\n                  effects=list(c(list(Int_occ=1), #the Intercept\n                                 iset_sp),  #the spatial index\n                               #the covariates\n                               as.list(X_cov)),\n                  tag='spat')\n\nNext we specify the prior for the temporal autoregressive parameter and the model formula:\n\n# PC prior for the temporal autocorrelation\nh.spec &lt;- list(rho = list(prior = 'pc.cor0', param = c(0.5, 0.3)))\n\n# extract unique values of the binned covariate\nval_xs = sort(unique(xx))\n\nformula_spat &lt;- inla.mdata(Y,X) ~ -1 + Int_occ +\n  f(group_xs, model = \"rw2\", values = val_xs)  +\n   f(time, model = \"iid\") +\n  f(spatialfield,\n    model=spde,\n    group = spatialfield.group,\n    control.group = list(model = 'ar1',hyper = h.spec))\n\n\n\n\n\n\n\nNote\n\n\n\n\n\nNotice that we have used the values argument when defining the rw2 effect to specify the values of the binned covariate at which we will like to do predictions (i.e., over the whole domain). Otherwise, the model would only look at the values of the binned covariate available in the data input.\n\n\n\nNext we run the model (note that we have used Empirical Bayes integration strategy for computational purpose, see Gómez-Rubio (2020) for further details):\n\nmodel_spat &lt;- inla(formula_spat, #the formula\n                   data=inla.stack.data(stk),  # the data stack\n                   family= 'occupancy',   # model likelihood\n                   control.fixed =  list(prec = 1, prec.intercept = 1),\n                                     control.predictor=list(A=inla.stack.A(stk),\n                                                            compute=TRUE),\n                   control.compute = list(waic = TRUE,config = TRUE),\n                      control.inla = list(int.strategy = \"eb\"),\n                   #model diagnostics and config = TRUE gives you the GMRF\n                   verbose = F,\n                   control.family = list(control.link = list(model = \"logit\"),\n                                         link.simple = \"logit\",\n                            hyper = list(beta1 = list(param = c(0,1/3),\n                                                              initial = 0),\n                                         beta2 = list(param = c(0,1/3)))\n                            ))\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nThis type of model, at the moment, have to be implemented using the “stack” options. We are working on this!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe posterior summaries (i.e. mean, quantiles, std.dev and mode) of the smooth term \\(f(x)\\) estimated using a RW2 are stored in model_spat$summary.random$group_xs. The estimated smooth term can then be plotted against the true function.\n\n\n\n\n\n\n\nFigure 3: Estimated smooth effect of simulated covariate x.\n\n\n\n\nModel hyper parameters marginal densities can be accessed through model_spat$marginals.hyperpar, posterior summaries of such are shown in Table 5\n\n\n\nTable 5: summary results for the space-time occupancy model hyperparameters for the detection linear predictor and the Matérn variance-covariance matrix.\n\n\n\n\npar\ntrue\nmean\nquant0.025\nquant0.975\n\n\n\n\\(\\alpha_0\\)\n-0.85\n-0.95\n-1.05\n-0.84\n\n\n\\(\\alpha_1\\)\n-1.50\n-1.40\n-1.53\n-1.27\n\n\npractical range\n100.00\n124.19\n81.55\n185.16\n\n\n\\(\\sigma\\)\n1.00\n1.03\n0.82\n1.27\n\n\n\\(\\rho\\)\n0.65\n0.52\n0.32\n0.71"
  },
  {
    "objectID": "index.html#spatial-predictions",
    "href": "index.html#spatial-predictions",
    "title": "Fitting Occupancy models with R-INLA",
    "section": "\n2.3 Spatial predictions",
    "text": "2.3 Spatial predictions\nIn order to do predictions over space and time, we will need the prediction data set we created before, which contains the components used to fit the model. First, the projection matrix A is computed (this will be used for evaluating the model posterior samples of the Gaussian field in the next step).\n\nA_spat = inla.spde.make.A(mesh= mesh, loc = cbind(pred_df$x, pred_df$y),\n                        group = pred_df$time)\n\nThen, posterior samples of the model will be drawn using the inla.posterior.sample() function. A function of the generated samples can be computed using the inla.posterior.sample.eval() function. To do so, we defined a function func_spat() to evaluate the linear predictor components on the posterior samples of the model.\n\nsamples_spat = inla.posterior.sample(1000, model_spat)\n\nfunc_spat = function(...)\n\n{\n  eta = (Int_occ + group_xs[as.numeric(as.factor(pred_df$group_xs))] +\n           (A_spat %*% spatialfield)[,1] + \n          time[pred_df$time])\n  eta\n\n}\n\neval_samples = inla.posterior.sample.eval(func_spat, samples_spat)\n\n\n\n\nSummaries of the posterior samples can then be appended to de prediction data frame for visualization (e.g., mean occupancy probabilities, linear predictor posterior mean, std. dev, difference in quantiles, etc.)\n\nCodeocc_probs = inla.link.logit(eval_samples, inverse = T)\n\npred_df_results = pred_df %&gt;%\n  mutate(eta_sd = apply(eval_samples,1,sd),\n         eta_mu = apply(eval_samples,1,mean),\n         psi_mu = apply(occ_probs,1,mean),\n         quant_range = apply(eval_samples,1,\n                             function(x){quantile(x,0.975)-quantile(x,0.025)})) %&gt;%\n  mutate(time = paste('time',time,sep=' '))\n\n\n\n\n\n\n\n\n\nFigure 4: Estimated mean occupancy probabilities from the space time occupancy model.\n\n\n\n\nWe can compare these results against the true simulated values downloadable here:\n\n\n\n Download simulated example\n\n\n\n\n\n\n\n\n\n\nFigure 5: True occupancy probabilities simulated from a spatiotemporal Gaussian field with Ar1 component."
  },
  {
    "objectID": "index.html#continuous-space-varying-trend",
    "href": "index.html#continuous-space-varying-trend",
    "title": "Fitting Occupancy models with R-INLA",
    "section": "\n3.1 Continuous space-varying trend",
    "text": "3.1 Continuous space-varying trend\nIn this section we will fit the following SVC occupancy model:\nwhere the logit-scaled occupancy probabilities at locations \\(i\\) on time \\(t\\) are modeled with a continuous-space varying trend \\(\\beta_{1}(i)\\) , a fixed intercept \\(\\beta_{0}\\) (although a spatially varying intercept \\(\\beta_{0}(i)\\) could be easily fitted as well), and \\(\\omega(i)\\), a Gaussian random field with Matérn covariance function. The detection probabilities and observed occurrences are modeled in the same way as before.\n\nCodesvc_data &lt;- read.csv(\"Occ_data_3.csv\")\nsource(\"detection_covariates_function.R\")\n\n\nsvc_data &lt;- svc_data %&gt;%\n  mutate(scale_time = c(scale(time)))\n\n\n\n\n\nFirst 6 entries of the occupancy SVC data\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncellid\ny1\ny2\ny3\ng1\ng2\ng3\ntime\nx.loc\ny.loc\nscale_time\n\n\n\n2\n1\n0\n0\n-0.66\n0.00\n-0.35\n1\n4.5\n1.5\n-1.41\n\n\n2\n0\n0\n0\n0.09\n0.87\n-0.94\n2\n4.5\n1.5\n-0.71\n\n\n2\n0\n0\n0\n0.26\n0.63\n-0.13\n3\n4.5\n1.5\n0.00\n\n\n2\n0\n0\n0\n-0.10\n0.93\n-0.70\n4\n4.5\n1.5\n0.71\n\n\n2\n0\n0\n0\n0.74\n-0.51\n0.92\n5\n4.5\n1.5\n1.41\n\n\n5\n0\n0\n0\n-0.08\n0.21\n0.74\n1\n13.5\n1.5\n-1.41\n\n\n\n\n\n\n\n Download data as xlsx\n\n\nFirst, the SPDE model is defined by using PC-priors for the model parameters.\n\nCodeboundary_sf = st_bbox(c(xmin = 0, xmax = 300, ymax = 0, ymin = 300)) %&gt;%\n  st_as_sfc() %&gt;% st_as_sf()\n\nmesh = fm_mesh_2d(loc.domain = st_coordinates(boundary_sf)[,1:2],\n                    offset = c(-0.1, -.2),\n                    max.edge = c(15, 30))\n\nspde &lt;- inla.spde2.pcmatern(mesh = mesh,\n                              prior.range = c(100, 0.5),\n                              prior.sigma = c(1, 0.5))\n\n\nNow we prepare and fit the data\n\n\nThe inla.stack() option (recommended)\nA.local argument (testing version)\n\n\n\nTwo sets of indexes need to be created for (i) the spatial field and (ii) the spatio-temporal component.\n\niset_sp1 &lt;- inla.spde.make.index(name = \"i1\",\n                                 n.spde =  spde$n.spde)\n\niset_sp2 &lt;- inla.spde.make.index(name = \"i2\",\n                                 n.spde =  spde$n.spde)\n\nFor the Spatial field \\(\\omega(i)\\), the projector matrix A mapping the model domain to the data locations is computed. As for the space-varying trend, this is represented as the Kronecker product of the projector matrix and the covariate vector, i.e., \\((\\mathbf{A}\\otimes (\\mathbf{x1})^T))\\beta_1\\) . Such computation is done internally within the inla.spde.make.A() function when the covariate vector gets passed on to the weights argument (in this case, the scaled-time covariate).\n\nA_sp1 &lt;- inla.spde.make.A(mesh = mesh,\n                         loc = as.matrix(svc_data[,c(\"x.loc\",\"y.loc\")]))\n#space-time projector matrix\nA_sp2 &lt;- inla.spde.make.A(mesh = mesh,\n                          loc = as.matrix(svc_data[,c(\"x.loc\",\"y.loc\")]),\n                          weights = svc_data$scale_time)\n\nFor building the stack both projector matrices and indexes must be specified.\n\nY_mat &lt;- svc_data %&gt;%\n  dplyr::select(num_range(\"y\",1:3)) %&gt;% \n  as.matrix()\nX_det &lt;- svc_data %&gt;%\n  dplyr::select(num_range(\"g\",1:3)) %&gt;% \n  inla.Occupancy_detCov()\nX_cov &lt;- svc_data %&gt;%\n  dplyr::select(c(time,scale_time)) %&gt;%\n  mutate(Int_occ = 1)\n\nstk &lt;- inla.stack(data=list(Y= Y_mat, X = X_det),\n                  A=list(A_sp1,A_sp2,1),\n                  effects=list(iset_sp1,\n                               iset_sp2,\n                               as.list(X_cov)),\n\n                  tag='SVC')\n\nThe model formulas include both spde models, which are then passed on to the inla function (note that we have used Empirical Bayes integration strategy for computational purpose, see Gómez-Rubio (2020) for further details).\n\nCodeformula_svc = inla.mdata(Y,X) ~\n  -1 + Int_occ +\n  f(i1, model=spde)  +\n  f(i2, model=spde)\n\nmodel_svc &lt;- inla(formula_svc, #the formula\n              data=inla.stack.data(stk),\n              family= 'occupancy',\n              control.fixed =  list(prec = 1, prec.intercept = 1),\n              control.predictor=list(A=inla.stack.A(stk),\n                                     compute=TRUE),\n              control.compute = list(dic = TRUE, waic = TRUE,\n                                     config = TRUE),\n              # verbose = TRUE,\n              control.inla = list(int.strategy = \"eb\"), \n              control.family = list(control.link = list(model = \"logit\"),\n                                    link.simple = \"logit\",\n                       hyper = list(beta1 = list(param = c(0,1/3),\n                                                              initial = 0),\n                                    beta2 = list(param = c(0,1/3)))\n                       ))\n\n\n\n\nFor the Spatial field \\(\\omega(i)\\), the projector matrix A mapping the model domain to the data locations is computed. As for the space-varying trend, this is represented as the Kronecker product of the projector matrix and the covariate vector, i.e., \\((\\mathbf{A}\\otimes (\\mathbf{x1})^T))\\beta_1\\) . Such computation is done internally within the inla.spde.make.A() function when the covariate vector gets passed on to the weights argument (in this case, the scaled-time covariate).\n\nA_sp1 &lt;- inla.spde.make.A(mesh = mesh,\n                         loc = as.matrix(svc_data[,c(\"x.loc\",\"y.loc\")]))\n\n#space-time projector matrix\n\nA_sp2 &lt;- inla.spde.make.A(mesh = mesh,\n                          loc = as.matrix(svc_data[,c(\"x.loc\",\"y.loc\")]),\n                          weights = svc_data$scale_time)\n\nWe can create a list containing the detection/non-detection matrix, the detection covariates, and a list containing the the intercept column for the base-line occupancy, the time points, and two empty vectors (since both space and space-time A projector matrices are provided in the A.local argument).\n\nY_mat &lt;- svc_data %&gt;%\n  dplyr::select(num_range(\"y\",1:3)) %&gt;% \n  as.matrix()\nX_det &lt;- svc_data %&gt;%\n  dplyr::select(num_range(\"g\",1:3)) %&gt;% \n  inla.Occupancy_detCov()\nX_cov &lt;- svc_data %&gt;%\n  dplyr::select(time,scale_time) %&gt;%\n  mutate(Int_occ = 1,\n         i1 = rep(NA,nrow(svc_data)),\n         i2 = rep(NA,nrow(svc_data)))\n\ndata_list &lt;- as.list(X_cov)\ndata_list$X &lt;- X_det\ndata_list$Y &lt;- Y_mat\n\nThe model formula includes both spde models, which are then passed on to the inla function (note that we have used Empirical Bayes integration strategy for computational purpose, see Gómez-Rubio (2020) for further details).\n\nformula_svc = inla.mdata(Y,X) ~\n  -1 + Int_occ +\n  f(i1, model=spde, A.local = A_sp1)  +\n  f(i2, model=spde, A.local = A_sp2)\n\nmodel_svc &lt;- inla(formula_svc, #the formula\n              data=data_list,\n              family= 'occupancy',\n              control.fixed =  list(prec = 1, prec.intercept = 1),\n              control.compute = list(dic = TRUE, waic = TRUE,\n                                     config = TRUE),\n              # verbose = TRUE,\n              control.inla = list(int.strategy = \"eb\"),\n              control.family = list(control.link = list(model = \"logit\"),\n                                    link.simple = \"logit\",\n                                    hyper = list(beta1 = list(param = c(0,1/3),\n                                                              initial = 0),\n                                                 beta2 = list(param = c(0,1/3),\n                                                              initial = 0))))"
  },
  {
    "objectID": "index.html#visualize-space-varying-trend",
    "href": "index.html#visualize-space-varying-trend",
    "title": "Fitting Occupancy models with R-INLA",
    "section": "\n3.2 Visualize space-varying trend",
    "text": "3.2 Visualize space-varying trend\nTo plot the predicted spatial trend, a fine grid covering the spatial domain must be created. We can use sf::st_make_grid() function to do this.\n\nCodeprojection_grid &lt;- st_make_grid(boundary_sf,cellsize = c(3,3)) %&gt;%\n  st_cast(\"MULTIPOLYGON\") %&gt;%\n  st_sf()\n\n\n\n\n\n\nPrediction grid for the SVC model\n\n\n\nOnce the prediction grid is created, a projector matrix A_pred is computed based on the locations of the grid. Posterior samples of the model are drawn, and the projector matrix is used to evaluate the spatio-temporal trend on the samples.\n\n# projector matrix\nA_pred = inla.spde.make.A(mesh, st_coordinates(projection_grid))\n\n# samples\nsamples = inla.posterior.sample(1000, model_svc)\n\n# evaluate the spatial temporal trend\nsvc_eval = inla.posterior.sample.eval(function(x) (A_pred %*% i2)[,1],\n\n                                 samples)\n\nWe can compute the posterior mean, median, quantiles, and also check for significance. This information can be appended into a prediction data frame and converting it to a SpatRaster for visualization.\n\nCodedd = data.frame(x = st_coordinates(projection_grid)[,1],\n                y = st_coordinates(projection_grid)[,2],\n                z = apply(svc_eval,1,mean),\n                q1 = apply(svc_eval,1,quantile,0.025),\n                q2 = apply(svc_eval,1,quantile,0.975)) %&gt;%\n  mutate(check = case_when( q1&gt;=0 & q2&gt;=0 ~1,\n\n                             q1&lt;0 & q2&lt;0 ~ -1,\n\n                             q1&lt;0 & q2&gt;0 ~ 0)) %&gt;%\n  terra::rast()\n\n\n\n\n\n\n\n\n\nFigure 6: Estimated spatiotemporal trend for a SVC model\n\n\n\n\nWe can also compute a the predicted occupancy probabilities at a fixed time point \\(t\\) by evaluating the linear predictor on the posterior samples. We define a function func_svc() to compute the the liner predictor for a given time point.\n\nfunc_svc = function(..., time)\n\n{\n  fix = Int_occ\n  spat = (A_pred %*% i1)[,1]\n  spat2 = (A_pred %*% i2)[,1] * sort(unique(svc_data$scale_time))[time]\n  return(fix + spat + spat2)\n\n}\n\nFor example, for \\(t=5\\) we can compute the posterior mean occupancy probability as follows:\n\nCode# select t= 5\n\ntime=5\n\n# evaluate the linear predictor on the posterior samples\n\neta_post = inla.posterior.sample.eval(func_svc, samples, time = 5)\n\ndd2 = data.frame(x = st_coordinates(projection_grid)[,1],\n                y = st_coordinates(projection_grid)[,2],\n                psi =apply(inla.link.logit(eta_post, inverse = T),1,mean)) %&gt;%\n\n  terra::rast()\n\n\nNow we can compare this result against the true simulated values available to be downloaded:\n\n\n\n Download simulated example\n\n\n\n\n\n\n\n\n\n\nFigure 7: SVC model estimated (left) and simulated (right) occupancy probabilitiesfor time point 5."
  },
  {
    "objectID": "index.html#regional-varying-trend",
    "href": "index.html#regional-varying-trend",
    "title": "Fitting Occupancy models with R-INLA",
    "section": "\n3.3 Regional Varying Trend",
    "text": "3.3 Regional Varying Trend\nNow suppose we are interested in modelling the regional varying trend \\(\\beta_{R_i}\\) for a set of \\(p\\) non-overlapping regions over the spatial domain, i.e. \\(\\mathcal{D} = \\bigcup\\limits_{i=1}^p R_i\\) such that \\(R_i\\bigcap R_j = \\emptyset\\) for each \\(i\\neq j\\). We can discretized the study area into 20 regions as follows:\n\nCodeR_i &lt;- st_make_grid(boundary_sf, cellsize = 90, square = FALSE) %&gt;%\n    st_cast(\"MULTIPOLYGON\") %&gt;%\n  st_sf() %&gt;%\n  mutate(cellid = row_number()) %&gt;%\n  st_crop(boundary_sf) %&gt;%\n  st_collection_extract( \"POLYGON\") %&gt;%\n  mutate(cellid = 1:length(cellid))\n\n\n\n\n\n\n\n\n\nFigure 8: Partition of the spatial domain into 20 non-overlapping Regions.\n\n\n\n\nThe regional varying trend \\(\\beta_{R_i}\\) in the linear predictor can be vary across the \\(p\\) discrete aerial units through \\(iid\\) random effects, or according to a spatial dependence structure modeled with an areal spatial process. For the latter case, the spatial structure is usually described by neighborhood matrices. The R-package spdep facilitates building a neighbors list based on the defined regions and then generates a weights matrix \\(\\mathbf{W}\\) (e.g. \\(w_{ij} = 1\\) if region \\(i\\) is neighbor of \\(j\\) and zero otherwise) .\n\nlibrary(spdep)\n\nN.adj &lt;- poly2nb(pl = R_i)\nW.nb&lt;- nb2mat(N.adj, style = \"B\")\n\nNext, we find the region id where each observation lies and append this information to the data set.\n\nsvc_data_sf &lt;-  svc_data %&gt;%\n  st_as_sf(coords = c('x.loc','y.loc'))\nsvc_data_R &lt;- svc_data_sf %&gt;% mutate(cellid = unlist(st_intersects(svc_data_sf,R_i)))\n\nThe spatial relationships can be described by one of INLA’s available areal spatial models (see inla.list.models(\"latent\") for a list of the latent models available in INLA). In this example, we will use the Besag-York-Mollié model (BYM) which is an extension to the intrinsic CAR model that contains an i.i.d. model component for the non-spatial heterogeneity, i.e.\nThus, slopes are sampled from a normal distribution, where the conditional mean is linked to the average of neighboring cells and a conditional variance proportional to the variance across adjacent cells and inversely proportional to the number of adjacent cells.\n\n\nThe inla.stack() option (recommended)\nA.local argument (testing version)\n\n\n\nFor fitting this model in INLA we need a spatial index for the spatial field \\(\\omega(i)\\) and projection matrix to map the model domain to the coordinates of the data.\n\niset_sp &lt;- inla.spde.make.index(name = \"spatialfield\",\n                                n.spde =  spde$n.spde)\n\nA_sp &lt;- inla.spde.make.A(mesh = mesh,\n                         loc = st_coordinates(svc_data_R))\n\nWe also need to supply the region index from the data as a numerical input in the stack effects list.\n\nstk &lt;- inla.stack(data=list(Y = Y_mat, X =X_det),\n                  A=list(A_sp,1),\n                  effects=list(iset_sp,\n                               data.frame(Int_occ = 1,\n                                    region_id = svc_data_R$cellid,\n                                    scale_time = svc_data_R$scale_time,\n                                    time = svc_data_R$time)),\n                  tag='SVC_R')\n\nTo fit the regional varying trend model with BYM structured spatial effects, the component related to the space-varying coefficient in the model formula must contain:\n\nThe region id (as defined in the data stack)\nThe covariate value (in this case the scaled-time)\nThe CAR model (model =\"bym\")\nThe weight matrix \\(\\mathbf{W}\\)\n\n\nformula_svc_R = inla.mdata(Y,X) ~\n  -1 + Int_occ +\n  f(region_id,scale_time, model = \"bym\", graph = W.nb)  +\n  f(spatialfield, model = spde)\n\nWe will save the inla output as model_svc_R :\n\nCodemodel_svc_R &lt;- inla(formula_svc_R, #the formula\n              data=inla.stack.data(stk),\n              family= 'occupancy',\n              control.fixed =  list(prec = 1, prec.intercept = 1),\n              control.predictor=list(A=inla.stack.A(stk),\n                                     compute=TRUE),\n              control.compute = list(dic = TRUE, waic = TRUE,\n                                     config = TRUE),\n              control.inla = list(int.strategy = \"eb\"),\n              control.family = list(control.link = list(model = \"logit\"),\n                                    link.simple = \"logit\",\n                                    hyper = list(beta1 = list(param = c(0,1/3),\n                                                              initial = 0),\n                                                 beta2 = list(param = c(0,1/3),\n                                                              initial = 0))\n                                    ))\n\n\n\n\nFor fitting this model in INLA we create the projection matrix to map the model domain to the coordinates of the data.\n\nA_sp &lt;- inla.spde.make.A(mesh = mesh,\n                         loc = st_coordinates(svc_data_R))\n\nWe create a list with the detection/non-detection data, detection covariates and a list of occupancy covariates including the time and region indeces/\n\nCodedata_list &lt;- svc_data_R %&gt;% \n  dplyr::select(cellid,time,scale_time) %&gt;%\n mutate(Int_occ = 1,\n         spatialfield = rep(NA,nrow(svc_data_R))) %&gt;%\n  rename(region_id=cellid) %&gt;%\n  st_drop_geometry() %&gt;%\n  as.list()\n\ndata_list$Y &lt;- Y_mat\ndata_list$X &lt;- X_det \n\n\nTo fit the regional varying trend model with BYM structured spatial effects, the component related to the space-varying coefficient in the model formula must contain:\n\nformula_svc_R = inla.mdata(Y,X) ~\n  -1 + Int_occ +\n  f(region_id,scale_time, model = \"bym\", graph = W.nb)  +\n  f(spatialfield, model = spde, A.local = A_sp)\n\nmodel_svc_R &lt;- inla(formula_svc_R, #the formula\n              data=data_list,\n              family= 'occupancy',\n              control.fixed =  list(prec = 1, prec.intercept = 1),\n              control.compute = list(dic = TRUE, waic = TRUE,\n                                     config = TRUE),\n              control.inla = list(int.strategy = \"eb\"),\n              control.family = list(control.link = list(model = \"logit\"),\n                                    link.simple = \"logit\",\n                        hyper = list(beta1 = list(param = c(0,1/3),\n                                                              initial = 0),\n                                    beta2 = list(param = c(0,1/3),\n                                                              initial = 0))\n                        ))\n\n\n\n\nTo visualize the results we can take the prediction grid created for the prediction of the continuous-space varying trend model and index each cell according to the region \\(R_i~\\mbox{for } i = 1,\\ldots,20\\).\n\n# add cellid to prediction grid\n\nprojection_grid_R &lt;- st_intersection(projection_grid,R_i)\n\n\n\n\n\n\n\n\nFigure 9: Grid for predicting the space-varying trend estimated with the Regional SVC model across 20 non-overlapping regions.\n\n\n\n\nNext, we compute posterior samples of the model to evaluate the trend for each cell indexed by region \\(R_i\\).\n\n# samples\nsamples = inla.posterior.sample(1000, model_svc_R)\n# evaluate the spatial temporal trend\n\nsvc_eval_R = inla.posterior.sample.eval(function(x)\n  (region_id[projection_grid_R$cellid]), samples)\n\nFinally, we can compute posterior quantities (i.e. the mean, quantiles, etc) and check for significance. This information can be appended directly into the prediction grid which can be then be rasterized using the stars R-package for visualization purposes.\n\n# append to prediction grid\n\nprojection_grid_R =projection_grid_R %&gt;%\n  mutate( z = apply(svc_eval_R,1,mean),\n          q1 = apply(svc_eval_R,1,quantile,0.025),\n          q2 = apply(svc_eval_R,1,quantile,0.975),\n          check = case_when( q1&gt;=0 & q2&gt;=0 ~1,\n\n                             q1&lt;0 & q2&lt;0 ~ -1,\n\n                             q1&lt;0 & q2&gt;0 ~ 0))\n\n# Rasterize\nregional_trend &lt;-stars::st_rasterize(projection_grid_R)\n\n\n\n\n\n\n\n\nFigure 10: Estimated regional varying trend from a SVC model."
  },
  {
    "objectID": "space_time_model.html",
    "href": "space_time_model.html",
    "title": "Space time Occupacy model with INLA",
    "section": "",
    "text": "In this document we show how to fit a space time occunpacy model for the dataset “hbefTrends” in the ‘spOccupacy’ library.\n\nlibrary(INLA) \nlibrary(tidyverse)\nlibrary(spOccupancy)\nlibrary(scico)\nlibrary(patchwork)\nlibrary(kableExtra)\nlibrary(sf)\nlibrary(terra)\nlibrary(tidyterra)\n\nrm(list = ls())\n\nplot_inla_effects = function(effect)\n{\n  p1 = ggplot(data.frame(effect)) +\n    geom_line(aes(ID, -mean)) + \n    geom_ribbon(aes(ID, ymin = -X0.025quant, ymax = -X0.975quant),\n                alpha = 0.5)\n  print(p1)\n  \n}\n\n\ntheme_maps = theme(axis.line=element_blank(),\n                   axis.text.x=element_blank(),\n                   axis.text.y=element_blank(),\n                   axis.ticks=element_blank(),\n                   axis.title.x=element_blank(),\n                   axis.title.y=element_blank()\n                   #legend.position=\"none\",\n                   #panel.background=element_blank(),\n                   #panel.border=element_blank(),\n                   #panel.grid.major=element_blank(),\n                   #panel.grid.minor=element_blank(),\n                   #plot.background=element_blank()\n)"
  },
  {
    "objectID": "space_time_model.html#model-1",
    "href": "space_time_model.html#model-1",
    "title": "Space time Occupacy model with INLA",
    "section": "Model 1",
    "text": "Model 1\nThis is a separable space time model with linear predictos \\[\n\\eta_{st} = \\beta_0 + f_1(\\text{elev}) + f_2(t) + f_3(s)\n\\] where \\(f_1(\\text{elev})\\) is a smooth (RW2) effect of the elevation \\(f_2(t)\\) is a AR1 effect of time \\(f_3(s)\\) is an IID effect of location\n\nformula1 = inla.mdata(Y,X) ~ -1 + Int_occ +  \n  #f(group_elev,model = \"rw2\", values = val_elev) + \n  scale_elev + \n  scale_elev2 + \n  f(site, model =  \"iid\") + \n  f(time, model = \"iid\")\n  #scale_time\n\n\ndata_list = as.list(Xocc)\ndata_list$Y = Y\ndata_list$X = Xdet\n\n\ntime0 = system.time(model1 &lt;- inla(formula1, \n                                   data=data_list,   \n                                   family= 'occupancy',   \n                                   verbose = FALSE,\n                                   control.compute = list( config = TRUE,\n                                                           dic  = T,\n                                                           waic = T),\n                                   control.fixed = list(prec.intercept = 1/2.72,\n                                                        prec = 1/2.72),\n                                   control.predictor = list(link  =1),\n                                   control.family = list(control.link = list(model = \"logit\"), \n                                                         link.simple = \"logit\",\n                                                         hyper = list(beta1 = list(param = c(0,1/2.72), \n                                                                                   initial = 0),\n                                                                      beta2 = list(param = c(0,1/2.72)),\n                                                                      beta3 = list(param = c(0,1/2.72)),\n                                                                      beta4 = list(param = c(0,1/2.72)),\n                                                                      beta5 = list(param = c(0,1/2.72))))))"
  },
  {
    "objectID": "space_time_model.html#model-2",
    "href": "space_time_model.html#model-2",
    "title": "Space time Occupacy model with INLA",
    "section": "Model 2",
    "text": "Model 2\n\n# set up spatial model for INLA\nboundary = inla.nonconvex.hull(points = revi.data$coords, convex = .3)\nmesh = inla.mesh.2d(boundary = boundary,\n                    #   loc = cbind(data$X, data$Y),\n                    max.edge = c(0.1,0.7),\n                    min.angle = 20,\n                    offset = c(.01, 1),\n                    cutoff = 0.12,\n)\nggplot() + inlabru::gg(mesh) +\n  coord_equal() + theme_maps\n\n\n\n\n\n\n\nspde &lt;- inla.spde2.pcmatern(\n  mesh = mesh, \n  prior.range = c(5, 0.01), # prior for range\n  prior.sigma = c(1, 0.5))  # prior for sd parameter\n\nThis is a space-time model with linear predictor as \\[\n\\eta_{st} = \\beta_0 + f_1(\\text{elev}) + f_2(t) + \\omega(s)\n\\] with \\(f_1()\\) and \\(f_2()\\) as before while \\(\\omega(s)\\) is a gaussian spatial field\n\niset_sp &lt;- inla.spde.make.index(name = \"spatialfield\",\n                                n.spde =  spde$n.spde,\n                                n.group = 9)\n\nA_sp &lt;- inla.spde.make.A(mesh = mesh, \n                         loc = cbind(Xocc$x, Xocc$y),\n                         group = Xocc$time)\n\n# stk &lt;- inla.stack(data=list(Y = Y,  X = X), #the response\n#                   A=list(A_sp,1),  #the A matrix; the 1 is included to make the list(covariates)\n#                   effects=list(c(list(Int_occ=1), #the Intercept\n#                                  iset_sp),  #the spatial index\n#                                #the covariates\n#                                list(scale_elev = scale(Xocc[,1]))), \n#                   tag='dat')\n\nstk &lt;- inla.stack(data=list(Y = Y,  X = Xdet), # The responde\n                  A=list(A_sp,1),  #the A matrix; the 1 is included to make the list(covariates)\n                  effects=list(c(list(Int_occ=1), #the Intercept\n                                 iset_sp),  #the spatial index\n                               #the covariates\n                               as.list(Xocc)), \n                  #this is a quick name so yo can call upon easily\n                  tag='dat')\n\nformula3_2 &lt;- inla.mdata(Y,X) ~ \n  -1 + Int_occ +  \n  #time +\n  scale_elev + scale_elev2 + \n  f(time, model = \"iid\") + \n  #f(group_elev, model = \"rw2\", values = val_elev) + \n  f(spatialfield, model=spde) \n\n\ntime2 = system.time(model3_2 &lt;- inla(formula3_2, \n                                     data=inla.stack.data(stk),  \n                                     family= 'occupancy',  \n                                     control.fixed =  list(prec = 1, prec.intercept = 1),\n                                     control.predictor=list(A=inla.stack.A(stk),\n                                                            compute=TRUE), \n                                     control.compute = list(dic = TRUE, waic = TRUE, \n                                                            config = TRUE), \n                                     verbose = F,\n                                    #control.inla=list(cmin=eps, b.strategy=\"keep\"),\n\n                                     control.family = list(control.link = list(model = \"logit\"), \n                                                           link.simple = \"logit\",\n                                                           hyper = list(beta1 = list(param = c(0,1/3), \n                                                                                   initial = 0),\n                                                                      beta2 = list(param = c(0,1/3)),\n                                                                      beta3 = list(param = c(0,1/3)),\n                                                                      beta4 = list(param = c(0,1/3)),\n                                                                      beta5 = list(param = c(0,1/3))))))"
  },
  {
    "objectID": "space_time_model.html#model-3",
    "href": "space_time_model.html#model-3",
    "title": "Space time Occupacy model with INLA",
    "section": "Model 3",
    "text": "Model 3\nThe last model is defined as: \\[\n\\eta_{st} = \\beta_0 + f_1(\\text{elev}) +  \\omega(s,t)\n\\] with \\(f_1()\\) is as before while \\(\\omega(s,t)\\) is a space-time gaussian spatial field with AR1 time component\n\nh.spec &lt;- list(rho = list(prior = 'pc.cor0', param = c(0.5, 0.1)))\nspde &lt;- inla.spde2.pcmatern(\n  mesh = mesh, \n  prior.range = c(5, 0.7),\n  prior.sigma = c(1, 0.5),\n  constr = T) \n\nformula3_3 &lt;- inla.mdata(Y,X) ~ \n  -1   + Int_occ + \n  scale_elev +\n  scale_elev2 + \n # f(group_elev, model = \"rw2\", values = val_elev) + \n  f(time, model = \"iid\") + \n  f(spatialfield, \n    model=spde, \n    group = spatialfield.group, \n    control.group = list(model = 'ar1', hyper = h.spec))\n\ntime3 = system.time(model3_3 &lt;- inla(formula3_3, #the formula\n                                     data=inla.stack.data(stk),  #the data stack\n                                     family= 'occupancy',   #which family the data comes from\n                                     control.fixed =  list(prec = 1, prec.intercept = 1),\n                                     control.predictor=list(A=inla.stack.A(stk),\n                                                            compute=TRUE),  #compute gives you the marginals of the linear predictor\n                                     control.compute = list(dic = TRUE, waic = TRUE, \n                                                            config = TRUE), #model diagnostics and config = TRUE gives you the GMRF\n                                    \n\n                                     verbose = F,\n                                     control.family = list(control.link = list(model = \"logit\"), \n                                                                                    link.simple = \"logit\",\n                                                           hyper = list(beta1 = list(param = c(0,10), \n                                                                                   initial = 0),\n                                                                      beta2 = list(param = c(0,10)),\n                                                                      beta3 = list(param = c(0,10)),\n                                                                      beta4 = list(param = c(0,10)),\n                                                                      beta5 = list(param = c(0,10))))))"
  },
  {
    "objectID": "space_time_model.html#results",
    "href": "space_time_model.html#results",
    "title": "Space time Occupacy model with INLA",
    "section": "Results",
    "text": "Results\n\nModel comparison\n\ndf_sf &lt;- Xocc %&gt;% mutate(id = 1:nrow(Xocc)) %&gt;% st_as_sf(coords =c(\"x\",\"y\"))\n\n# create buffer of size 300 (based on estimated range) centred at each site\n\nbuffer_25 &lt;- st_buffer(df_sf, dist = 0.75) \n\n# empty lists to include the indexes of the leave-out-group for each observation i\nI_i &lt;- list()\n\n# loop though each observation and store the leave-out-group based on the buffer\nfor( i in 1:nrow(df_sf)){\n  \n  # Temporal filtering of data within a 2 years of span of  observation i\n  df_sf_subset &lt;- df_sf %&gt;% \n    filter( between(time,left = df_sf$time[i]-2, right = df_sf$time[i]+2)) \n  # Spatial filtering of the observations that are within the buffer of the ith observation\n  Buffer_i &lt;-df_sf_subset %&gt;% st_intersects(buffer_25[i,],sparse = FALSE) %&gt;% # identify \n    unlist()\n  \n  # obtain the indexes of the leave out group\n  I_i[[i]] &lt;-  df_sf_subset[Buffer_i,] %&gt;%  pull(id)\n  \n}\n\n## Example for the the 200th test point  \nggplot()+geom_sf(data=df_sf)+\n  facet_wrap(~time)+\n  geom_sf(data=df_sf[I_i[[1500]],],color=\"orange\")+\n  geom_sf(data = df_sf[1500,],colour=\"purple\") +\n  geom_sf(data=buffer_25[1500,],color=\"red\",alpha=0)\n\n\n\n\n\n\n\nloocv_m1_auto &lt;- inla.group.cv(result = model1,num.level.sets = 3)\nULOOCV_auto  = mean(log(loocv_m1_auto$cv),na.rm=T)\n\nloocv_m2_auto &lt;- inla.group.cv(result = model3_2,group.cv = loocv_m1_auto)\nULOOCV2_auto  = mean(log(loocv_m2_auto$cv),na.rm=T)\n\nloocv_m3_auto &lt;- inla.group.cv(result = model3_3,group.cv = loocv_m1_auto)\nULOOCV3_auto = mean(log(loocv_m3_auto$cv),na.rm=T)\n\n\nloocv_m1_manual &lt;- inla.group.cv(result = model1,groups = I_i )\nULOOCV_manual = mean(log(loocv_m1_manual$cv),na.rm=T)\n\nloocv_m2_manual &lt;- inla.group.cv(result = model3_2,group.cv = loocv_m1_manual)\nULOOCV2_manual = mean(log(loocv_m2_manual$cv),na.rm=T)\n\nloocv_m3_manual &lt;- inla.group.cv(result = model3_3,group.cv = loocv_m1_manual)\nULOOCV3_manual = mean(log(loocv_m3_manual$cv),na.rm=T)\n\n\n data.frame(auto= c(ULOOCV_auto,ULOOCV2_auto,ULOOCV3_auto),\n            manual=c(ULOOCV_manual,ULOOCV2_manual,ULOOCV3_manual))\n\n       auto    manual\n1 -1.620348 -1.628802\n2 -1.609643 -1.630196\n3 -1.600538 -1.620589\n\n\n\ntable = data.frame(elapsed_Time = c(time0[\"elapsed\"], time2[\"elapsed\"], time3[\"elapsed\"]),\n                    DIC = c(model1$dic$dic, model3_2$dic$dic, model3_3$dic$dic),\n                    WAIC = c(model1$waic$waic, model3_2$waic$waic, model3_3$waic$waic),\n                    mlik = c(model1$mlik[1,1],model3_2$mlik[1,1],model3_3$mlik[1,1]),\n                    LGOCV_auto = c(ULOOCV_auto,ULOOCV2_auto,ULOOCV3_auto),\n                    LGOCV_manual = c(ULOOCV_manual,ULOOCV2_manual,ULOOCV3_manual))\n rownames(table) = paste(\"Model\", c(1:3))\n kable(table)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nelapsed_Time\nDIC\nWAIC\nmlik\nLGOCV_auto\nLGOCV_manual\n\n\n\n\nModel 1\n2.081\n9842.983\n9819.026\n-5053.713\n-1.620348\n-1.628802\n\n\nModel 2\n10.872\n9805.774\n9796.270\n-5021.079\n-1.609643\n-1.630196\n\n\nModel 3\n595.246\n9768.112\n9747.819\n-5002.419\n-1.600538\n-1.620589\n\n\n\n\n#tt = round(table,2)\n#cbind(row.names(table),paste(tt[,1],\"(\",tt[,2],\",\",tt[,3],\")\", sep = \"\"))\n\ntt = round(rbind(model1$summary.fixed[,c(1,3,5)],\n      model3_2$summary.fixed[,c(1,3,5)],\n      model3_3$summary.fixed[,c(1,3,5)]),2)\ncbind(row.names(tt),paste(tt[,1],\"(\",tt[,2],\",\",tt[,3],\")\", sep = \"\")) \n\n      [,1]           [,2]                \n [1,] \"Int_occ\"      \"1.67(0.89,2.42)\"   \n [2,] \"scale_elev\"   \"-1.44(-1.64,-1.25)\"\n [3,] \"scale_elev2\"  \"-0.63(-0.78,-0.48)\"\n [4,] \"Int_occ1\"     \"0.91(-0.13,1.77)\"  \n [5,] \"scale_elev1\"  \"-0.87(-1.57,-0.03)\"\n [6,] \"scale_elev21\" \"-1(-1.46,-0.6)\"    \n [7,] \"Int_occ2\"     \"0.92(0.48,1.36)\"   \n [8,] \"scale_elev3\"  \"-1.38(-1.74,-1)\"   \n [9,] \"scale_elev22\" \"-0.73(-1.01,-0.46)\""
  },
  {
    "objectID": "space_time_model.html#predictions-over-space",
    "href": "space_time_model.html#predictions-over-space",
    "title": "Space time Occupacy model with INLA",
    "section": "Predictions over space",
    "text": "Predictions over space\n\nyy = c(1,9)\npred1 = pred_df %&gt;% dplyr::filter(time%in%yy)\nA3_2 = inla.spde.make.A(mesh= mesh, loc = cbind(pred1$x, pred1$y))\nA3_3 = inla.spde.make.A(mesh= mesh, loc = cbind(pred1$x, pred1$y),\n                        group = pred1$time)\n\nfunc1 = function(...)\n{\n   aa = (Int_occ + \n           scale_elev * pred1$scale_elev +\n          scale_elev2 * pred1$scale_elev2 +\n          time[pred1$time]\n  )\n  rand = rnorm(length(pred1$scale_elev), 0, 1/sqrt(theta[4]))\n  aa + \n    rand\n}\nfunc3_2 = function(...)\n{\n  aa = (Int_occ + \n           scale_elev * pred1$scale_elev +\n          scale_elev2 * pred1$scale_elev2 +\n           time[pred1$time] +\n           (A3_2 %*% spatialfield)[,1] )\n  aa\n}\nfunc3_3 = function(...)\n{\n  aa = (Int_occ + \n           scale_elev * pred1$scale_elev +\n          scale_elev2 * pred1$scale_elev2 +\n           time[pred1$time] +\n           (A3_3 %*% spatialfield)[,1] \n  )\n  aa\n}\nfix1 = inla.posterior.sample.eval(func1, sample1)\nfix3_2 = inla.posterior.sample.eval(func3_2, sample2)\nfix3_3 = inla.posterior.sample.eval(func3_3, sample3)\n\n\npred2 = pred1 %&gt;%\n  mutate(sd1 = apply(fix1,1,sd),\n         mean1 = apply(fix1,1,mean),\n         sd2 = apply(fix3_2,1,sd),\n         mean2 = apply(fix3_2,1,mean),\n         sd3 = apply(fix3_3,1,sd),\n         mean3 = apply(fix3_3,1,mean)) \n\n\n# New facet label names for time variable\ntime.labs &lt;-  c(\"2010\", \"2018\") \nnames(time.labs) &lt;- c(\"1\", \"9\")\n\n# New facet label names for name variable\nmodel.labs &lt;- c(\"Model 1\", \"Model 2\",\"Model 3\")\nnames(model.labs) &lt;- c(\"mean1\", \"mean2\",\"mean3\")\n\npred2 %&gt;% dplyr::select(x,y,time, mean1, mean2, mean3) %&gt;%\n  pivot_longer(-c(x,y,time)) %&gt;%\n  ggplot() + geom_tile(aes(x,y,fill = value)) +\n  coord_equal() + \n  facet_grid(time~name,labeller = labeller(time = time.labs, name = model.labs)) + scale_fill_scico(name=\"Occupancy \\nprobability \\n(logit-scaled)\") + theme_maps +\n   theme(text=element_text(family=\"serif\", size=20),\n                                               legend.text = element_text(size=16))\n\n\n\n\n\n\n\nggsave(filename = \"space_time_Occ_lprobs.pdf\",dpi = 300,width = 4000,units = \"px\")\n\n\n# New facet label names for name variable\nmodel.labs &lt;- c(\"Model 1\", \"Model 2\",\"Model 3\")\nnames(model.labs) &lt;- c(\"sd1\", \"sd2\",\"sd3\")\n\npred2 %&gt;% dplyr::select(x,y,time, sd1, sd2, sd3) %&gt;%\n  pivot_longer(-c(x,y,time)) %&gt;%\n  ggplot() + geom_tile(aes(x,y,fill = value)) +\n  coord_equal() + \n  facet_grid(time~name,labeller = labeller(time = time.labs, name = model.labs)) + scale_fill_scico(name=\"Occupancy \\nprobability  sd\\n(logit-scaled)\") + theme_maps +\n   theme(text=element_text(family=\"serif\", size=20),\n                                               legend.text = element_text(size=16))\n\n\n\n\n\n\n\nggsave(filename = \"space_time_Occ_lprobsSD.pdf\",dpi = 300,width = 4000,units = \"px\")\n\n#' Probability of occurrence\n\nprobs1 = inla.link.logit(fix1, inverse = T)\nquant1 = apply(probs1,1,quantile, c(0.025, 0.975))\nprobs2 = inla.link.logit(fix3_2, inverse = T)\nquant2 = apply(probs2,1,quantile, c(0.025, 0.975))\nprobs3 = inla.link.logit(fix3_3, inverse = T)\nquant3 = apply(probs3,1,quantile, c(0.025, 0.975))\n\npred2 = pred1 %&gt;%\n  mutate(mean1 = apply(probs1,1,mean),\n         quant_range1 = quant1[2,]-quant1[1,],\n         mean2 = apply(probs2,1,mean),\n         quant_range2 = quant2[2,]-quant2[1,],\n         mean3 = apply(probs3,1,mean),\n         quant_range3 = quant3[2,]-quant3[1,]) \n\npred2 %&gt;% dplyr::select(x,y,time, mean1, mean2, mean3) %&gt;%\n  pivot_longer(-c(x,y,time)) %&gt;%\n  ggplot() + geom_tile(aes(x,y,fill = value)) +\n  coord_equal() + \n   facet_grid(time~name,labeller = labeller(time = time.labs, name = model.labs)) + scale_fill_scico(name=\"Occupancy \\nprobability\") + theme_maps +\n   theme(text=element_text(family=\"serif\", size=20),\n                                               legend.text = element_text(size=16))\n\n\n\n\n\n\n\nggsave(filename = \"space_time_Occ_probs.pdf\",dpi = 300,width = 4000,units = \"px\")\n\nmodel.labs &lt;- c(\"Model 1\", \"Model 2\",\"Model 3\")\nnames(model.labs) &lt;- c(\"quant_range1\", \"quant_range2\",\"quant_range3\")\n\npred2 %&gt;% dplyr::select(x,y,time, quant_range1, quant_range2, quant_range3) %&gt;%\n  pivot_longer(-c(x,y,time)) %&gt;%\n  ggplot() + geom_tile(aes(x,y,fill = value)) +\n  coord_equal() + \n  facet_grid(time~name,labeller = labeller(time = time.labs, name = model.labs)) + scale_fill_scico(name=\"Difference in \\nquantile\") + theme_maps +\n   theme(text=element_text(family=\"serif\", size=20),\n                                               legend.text = element_text(size=16))\n\n\n\n\n\n\n\nggsave(filename = \"space_time_Occ_qunatiles.pdf\",dpi = 300,width = 4000,units = \"px\")"
  },
  {
    "objectID": "space_time_model.html#parameters-for-the-detection-part-of-the-model",
    "href": "space_time_model.html#parameters-for-the-detection-part-of-the-model",
    "title": "Space time Occupacy model with INLA",
    "section": "Parameters for the detection part of the model",
    "text": "Parameters for the detection part of the model\n\n# detection paramters ------------------------------------------------------\n\nnpar = 3\ntab1 = rbind(model1$summary.hyperpar[1:npar,c(1,3,5)],\n             model3_2$summary.hyperpar[1:npar,c(1,3,5)],\n             model3_3$summary.hyperpar[1:npar,c(1,3,5)])\nrownames(tab1) = c (c(\"Int detection1\", \"day1\", \"tod1\"),\n                    c(\"Int detection2\", \"day2\", \"tod2\"),\n                    c(\"Int detection3\", \"day3\", \"tod3\"))\n\nkable(tab1, booktabs = TRUE, digits = 2) %&gt;% pack_rows(\n  index = c(\"Model 1\" = npar, \"Model 2\" = npar, \"Model 3\" = npar))\n\n\n\n\n\nmean\n0.025quant\n0.975quant\n\n\n\n\nModel 1\n\n\nInt detection1\n0.24\n0.18\n0.29\n\n\nday1\n-0.01\n-0.06\n0.04\n\n\ntod1\n-0.03\n-0.08\n0.03\n\n\nModel 2\n\n\nInt detection2\n0.22\n0.16\n0.28\n\n\nday2\n-0.01\n-0.06\n0.05\n\n\ntod2\n-0.03\n-0.08\n0.03\n\n\nModel 3\n\n\nInt detection3\n0.23\n0.17\n0.29\n\n\nday3\n-0.01\n-0.06\n0.05\n\n\ntod3\n-0.03\n-0.08\n0.03\n\n\n\n\n\n\n#tt = round(tab1,2)\n#cbind(row.names(tab1),paste(tt[,1],\"(\",tt[,2],\",\",tt[,3],\")\", sep = \"\"))"
  },
  {
    "objectID": "space_time_model.html#using-spoccupancy",
    "href": "space_time_model.html#using-spoccupancy",
    "title": "Space time Occupacy model with INLA",
    "section": "Using spOccupancy",
    "text": "Using spOccupancy\n\nlibrary(spOccupancy)\n\nrevi.sp.occ.formula &lt;- ~ scale(elev) + scale(elev)^2 + scale(years)\nrevi.sp.det.formula &lt;- ~ scale(day) +  scale(tod)\n\n\nz.inits &lt;- apply(revi.data$y, c(1, 2), function(a) as.numeric(sum(a, na.rm = TRUE) &gt; 0))\n# Pair-wise distance between all sites\ndist.hbef &lt;- dist(revi.data$coords)\nrevi.sp.inits &lt;- list(beta = 0, alpha = 0, z = z.inits,\n                      sigma.sq = 1, phi = 3 / mean(dist.hbef),\n                      sigma.sq.t = 1.5, rho = 0.2)\nrevi.sp.priors &lt;- list(beta.normal = list(mean = 0, var = 2.72),\n                       alpha.normal = list(mean = 0, var = 2.72),\n                       sigma.sq.t.ig = c(2, 0.5),\n                       rho.unif = c(-1, 1),\n                       sigma.sq.ig = c(2, 1),\n                       phi.unif = c(3 / max(dist.hbef), 3 / min(dist.hbef)),\n                       nu.unif =c(0,1))\n\ncov.model &lt;- 'matern'\nn.neighbors &lt;- 5\nar1 &lt;- FALSE\n\nn.batch &lt;- 600\nbatch.length &lt;- 25\nn.burn &lt;- 10000\nn.thin &lt;- 20\n\n\n# Approx. run time: ~ 2.5 min\nout.sp &lt;- stPGOcc(occ.formula = revi.sp.occ.formula,\n                   det.formula = revi.sp.det.formula,\n                   data = revi.data,\n                   inits = revi.sp.inits,\n                   priors = revi.sp.priors,\n                   cov.model = cov.model,\n                   n.neighbors = n.neighbors,\n                   n.batch = n.batch,\n                   batch.length = batch.length,\n                   verbose = TRUE,\n                   ar1 = ar1,\n                   n.report = 200,\n                   n.burn = n.burn,\n                   n.thin = n.thin,\n                   n.chains = 3)\n\n\nout.sp|&gt;summary()\n\n# Number of prediction sites.\nJ.pred &lt;- nrow(hbefElev)\n# Number of prediction years.\nn.years.pred &lt;- 2\n# Number of predictors (including intercept)\np.occ &lt;- ncol(out.sp$beta.samples)\n# Get covariates and standardize them using values used to fit the model\nelev.pred &lt;- (hbefElev$val - mean(revi.data$occ.covs$elev)) / sd(revi.data$occ.covs$elev)\nyear.pred &lt;- matrix(rep((c(2010, 2018) - mean(revi.data$occ.covs$years)) /\n            sd(revi.data$occ.covs$years),\n                    length(elev.pred)), J.pred, n.years.pred, byrow = TRUE)\n# Create three-dimensional array\nX.0 &lt;- array(1, dim = c(J.pred, n.years.pred, p.occ))\n# Fill in the array\n# Years\nX.0[, , 2] &lt;- year.pred\n# Elevation\nX.0[, , 3] &lt;- elev.pred\n# Elevation^2\nX.0[, , 4] &lt;- elev.pred^2\n# Check out the structure\nstr(X.0)\n# Indicate which primary time periods (years) we are predicting for\nt.cols &lt;- c(1, 9)\n# Approx. run time: &lt; 30 sec\ncoords.0 &lt;- cbind(hbefElev$Easting,hbefElev$Northing)\nout.pred &lt;- predict(out.sp, X.0,coords.0, t.cols = t.cols, ignore.RE = TRUE, type = 'occupancy')\n# Check out the structure\nstr(out.pred)\nplot.dat &lt;- data.frame(x = hbefElev$Easting,\n                       y = hbefElev$Northing,\n                       mean.2009.psi = apply(out.pred$psi.0.samples[, , 1], 2, mean),\n                       mean.2018.psi = apply(out.pred$psi.0.samples[, , 2], 2, mean),\n                       sd.2009.psi = apply(out.pred$psi.0.samples[, , 1], 2, sd),\n                       sd.2018.psi = apply(out.pred$psi.0.samples[, , 2], 2, sd),\n                       stringsAsFactors = FALSE)\n# Make a species distribution map showing the point estimates,\n# or predictions (posterior means)\ndat.stars &lt;- st_as_stars(plot.dat, dims = c('x', 'y'))\n# 2009\nggplot() +\n  geom_stars(data = dat.stars, aes(x = x, y = y, fill = mean.2009.psi)) +\n  scale_fill_viridis_c(na.value = 'transparent') +\n  labs(x = 'Easting', y = 'Northing', fill = '',\n       title = '') +\n  theme_bw()\n\n\n\ndata %&gt;% \n  group_by(time) %&gt;%\n  summarise(m = mean(counts/nvisits)) %&gt;%\n  ggplot() + geom_point(aes(x = time, y = m))"
  },
  {
    "objectID": "projects.html",
    "href": "projects.html",
    "title": "Data Simulation",
    "section": "",
    "text": "This section describes the steps to simulate occurrence data for fitting spatially explicit occupancy models in R-INLA."
  },
  {
    "objectID": "projects.html#state-process-model-sub-component",
    "href": "projects.html#state-process-model-sub-component",
    "title": "Data Simulation",
    "section": "\n2.1 State process model sub-component",
    "text": "2.1 State process model sub-component\nDefine model parameters \\(\\beta\\) and compute the occupancy probabilities \\(\\psi\\) and occupancy states \\(z\\) (Figure 3)\n\nCode# State process model coeficcients\nbeta &lt;- c(NA,NA)\nbeta[1] &lt;-  qlogis(0.3) # Base line occupancy probability\nbeta[2] &lt;- 1.5  # environmental covariate effect\n\n# Occupancy probabilities\npsi &lt;- inla.link.logit(beta[1] + beta[2]*x_s + omega_s, inverse = T)\n\n# True occupancy state\n\nset.seed(seed)\nz &lt;- rbinom(ncells, size = 1, prob = psi)\n\n\n\n\n\n\n\n\n\nFigure 3: Simulated occupancy probabilities and true presence/absence state"
  },
  {
    "objectID": "projects.html#sec-obs_model",
    "href": "projects.html#sec-obs_model",
    "title": "Data Simulation",
    "section": "\n2.2 Observational process model sub-component",
    "text": "2.2 Observational process model sub-component\nFirs, a random sample of 20 % of the total cells is obtained.\n\nCode# number of cells/sites in the sample\nnsites = round(ncells*.20)\nsite_id = sample(1:ncells, size=nsites, replace=FALSE) # cell id\n# add an indicator of whether a cell is in the sample or not\ncustomGrid$sample &lt;- ifelse(customGrid$cellid%in%site_id,1,0)\n\n\nThen, we define model parameters \\(\\alpha\\) , detection probabilities \\(p\\) and observed number of occurrences \\(y\\) across \\(K=3\\) visits per site/cell (Figure 4). Additionally, a survey-level covariate \\(g_2\\) is simulated at every surveyed cell to allow detection probabilities to vary by visit.\n\nCode# Number of vistis\nK= 3\n# Observational process model coeficcients\nalpha &lt;- c(NA,NA,NA)\nalpha[1] &lt;- qlogis(0.6) # Base line detection probability\nalpha[2] &lt;- 1 # detection covariate g1 effect\nalpha[3] &lt;- 0.5 # detection covariate g2 effect\n\n# Survey-level detection covariate g2\ng2 &lt;- array(runif(n = nsites * K, -1, 1), dim = c(nsites, K))\n\n# Detection probabilities and observed occurrences\n# Create empty matrix to store the results\ny &lt;- p.mat &lt;- matrix(NA,nrow = nsites,ncol=3) \n\n# loop over visits\nfor(j in 1:K){\n p.mat[,j] &lt;- inla.link.logit(alpha[1] + \n                              alpha[2]*g_s[site_id] + \n                              alpha[3]*g2[, j], inverse = T)\n y[,j] &lt;- rbinom(n = nsites,size = 1,prob = p.mat[,j]*z[site_id] )\n}\n\n\nCreate data set Table 1:\n\nCode# centroid of the cell\n\nOcc_data_1 &lt;- customGrid %&gt;%\n  st_centroid() %&gt;%\n  filter(sample==1) %&gt;%\n  dplyr::select(-c('sample'))\n\nObs_data &lt;- data.frame(y = y, # detectio/non-detection data\n           g2 = g2, # survey level covariate\n           cellid = site_id)\n\nOcc_data_1 &lt;- left_join(Occ_data_1,Obs_data,by = \"cellid\") \n\n# append coordinates as columns\n\nOcc_data_1[,c('x.loc','y.loc')] &lt;- st_coordinates(Occ_data_1)\nOcc_data_1 = st_drop_geometry(Occ_data_1)\n# Save CSV file for analysis\nwrite.csv(Occ_data_1,file='Occ_data_1.csv',row.names = F)\n\n\n\n\n\nTable 1: First 6 entries of the occupancy data\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncellid\ny.1\ny.2\ny.3\ng2.1\ng2.2\ng2.3\nx.loc\ny.loc\n\n\n\n2\n0\n0\n0\n0.5714531\n0.3866185\n-0.2529522\n4.5\n1.5\n\n\n5\n1\n1\n1\n-0.1941702\n-0.7073133\n0.4481461\n13.5\n1.5\n\n\n6\n1\n1\n1\n-0.3740240\n0.9385314\n-0.1100978\n16.5\n1.5\n\n\n7\n0\n1\n1\n0.3056664\n0.5610409\n0.7647462\n19.5\n1.5\n\n\n9\n1\n1\n1\n0.6081176\n-0.4150512\n0.1087413\n25.5\n1.5\n\n\n23\n1\n1\n1\n0.1278117\n-0.9585974\n-0.9708703\n67.5\n1.5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 4: Observed detection/non-detection records at sampled sites and true occupancy state."
  },
  {
    "objectID": "projects.html#footnotes",
    "href": "projects.html#footnotes",
    "title": "Data Simulation",
    "section": "Footnotes",
    "text": "Footnotes\n\nNote: If you are using INLA development version you might need modify the book.rspde function. Specifically, change the inla.mesh.project function to fmesher::fm_evaluator function to project the mesh into the domain coordinates.↩︎"
  }
]