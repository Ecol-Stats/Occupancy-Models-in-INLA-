---
title: "Space time Occupacy model with INLA"
format: 
  html:
    embed-resources: true
editor: source
  markdown: 
    wrap: 72
editor_options: 
  chunk_output_type: console
bibliography: references.bib
execute: 
  echo: true
  warning: false
  message: false
  collapse: true
---

# Introduction

In this document we show how to fit a space time occupacy model for the dataset "hbefTrends" in the 'spOccupacy' library.

```{r setup}
#| message: false
#| warning: false

library(INLA) 
library(tidyverse)
library(spOccupancy)
library(scico)
library(patchwork)
library(kableExtra)
  library(raster)
library(sf)

rm(list = ls())

plot_inla_effects = function(effect)
{
  p1 = ggplot(data.frame(effect)) +
    geom_line(aes(ID, -mean)) + 
    geom_ribbon(aes(ID, ymin = -X0.025quant, ymax = -X0.975quant),
                alpha = 0.5)
  print(p1)
  
}


theme_maps = theme(axis.line=element_blank(),
                   axis.text.x=element_blank(),
                   axis.text.y=element_blank(),
                   axis.ticks=element_blank(),
                   axis.title.x=element_blank(),
                   axis.title.y=element_blank()
                   #legend.position="none",
                   #panel.background=element_blank(),
                   #panel.border=element_blank(),
                   #panel.grid.major=element_blank(),
                   #panel.grid.minor=element_blank(),
                   #plot.background=element_blank()
)
```

# Load and prepare the data

We first load the data and select the species of interest. Here we choose BTBW which is not one of the rare species present in the dataset.

Afterwards we prepare the data in the format that is required by the INLA library

```{r}

data(hbefTrends)

revi.data <- hbefTrends
sp.names <- dimnames(hbefTrends$y)[[1]]
revi.data$y <- revi.data$y[sp.names == 'REVI', , , ]
revi.data$coords = revi.data$coords/1000 #get this in km!

## data preparation for inla -----------------------------------------------
data = data.frame(revi.data$coords,
                  elev = revi.data$occ.covs$elev,
                  site = 1:373,
                  apply(revi.data$y,c(1,2), sum, na.rm = T)
) %>%
  pivot_longer(-c(X,Y,elev, site), names_to = "year", values_to = "counts") %>%
  mutate(time = as.numeric(as.factor(year)))

mday = data.frame(revi.data$coords,
                  apply(revi.data$det.covs$day,c(1,2), mean, na.rm = T)) %>%
  pivot_longer(-c(X,Y))
mtod = data.frame(revi.data$coords,
                  apply(revi.data$det.covs$tod,c(1,2), mean, na.rm = T)) %>%
  pivot_longer(-c(X,Y))
nsamples = data.frame(revi.data$coords, apply(revi.data$y,c(1,2), 
                                              function(x) sum(!is.na(x)))) %>%
  pivot_longer(-c(X,Y))

data = data %>%
  mutate(nvisits = nsamples$value,
         mday = mday$value,
         mtod = mtod$value) %>%
  dplyr::filter(nvisits >0)

data = data %>%  mutate(scale_mday = as.vector(scale(mday)),
                        scale_mtod = as.vector(scale(mtod)),
                        scale_time = as.vector(scale(time)),
                        scale_elev = as.vector(scale(elev))) %>%
  mutate(scale_elev2 = scale_elev^2,
         scale_mday2 = as.vector(scale(mday^2)),
         int_detection = 1)



data %>% ggplot() + 
  geom_point(aes(X,Y, color= counts/nvisits), size = .5) + 
  facet_wrap(.~time) + theme_maps +
  scale_color_scico(na.value = "transparent") +
  ggtitle("Data")

```

```{r}
elev_raster= raster::rasterFromXYZ(data.frame(x = hbefElev$Easting/1000,
                                              y = hbefElev$Northing/1000,
                                              z = hbefElev$val))

elev_raster2 = resample(elev_raster, raster(nrows=100, ncols=100, 
                                            xmn=274, xmx=284,
                                            ymn=4866, ymx=4872, 
                                            vals=NULL))
values(elev_raster2) <- (values(elev_raster2) - mean(revi.data$occ.covs$elev)) / sd(revi.data$occ.covs$elev)


scale_time1 = (c(1:9) - mean(1:9))/sd(1:9)
pred_df = data.frame(x = rep(coordinates(elev_raster2)[,1],9),
                     y = rep(coordinates(elev_raster2)[,2],9),
                     scale_elev = rep(values(elev_raster2),9),
                     scale_time = rep(scale_time1, 
                                      each = length(values(elev_raster2))),
                     time = rep(c(1:9), each= length(values(elev_raster2)))) %>%
  dplyr::filter(!is.na(scale_elev))

xx = inla.group(c(data$scale_elev, pred_df$scale_elev),
                n = 35)


data$group_elev = xx[1:dim(data)[1]]
pred_df$group_elev = xx[-c(1:dim(data)[1])]

val_elev = sort(unique(xx))

```

# Model fit

## Model 1

This is a separable space time model with linear predictos $$
\eta_{st} = \beta_0 + f_1(\text{elev}) + f_2(t) + f_3(s)
$$ where $f_1(\text{elev})$ is a smooth (RW2) effect of the elevation $f_2(t)$ is a AR1 effect of time $f_3(s)$ is an IID effect of location

```{r}
yy = c(1:9)
data1 = data %>% dplyr::filter(time %in% yy ) %>%
  mutate(random = seq_along(X))

formula1 = inla.mdata(cbind(counts,nvisits),
                      int_detection, scale_mday, scale_mday2) ~ 
  f(group_elev,model = "rw2", values = val_elev) + 
  f(site, model =  "iid") + 
  f(time, model = "iid")

time0 = system.time(model1 <- inla(formula1, 
                                   data=data1,  
                                   family= '0binomialS',   
                                   verbose = FALSE,
                                   control.compute = list( config = TRUE,
                                                           dic  = T,
                                                           waic = T),
                                   control.fixed = list(prec.intercept = 1/2.72,
                                                        prec = 1/2.72),
                                   control.family = list(control.link = list(model = "logit"), 
                                                         link.simple = "logit",
                                                         hyper = list(beta1 = list(param = c(0,1/2.72), 
                                                                                   initial = 0),
                                                                      beta2 = list(param = c(0,1/2.72)),
                                                                      beta3 = list(param = c(0,1/2.72)),
                                                                      beta4 = list(param = c(0,1/2.72)),
                                                                      beta5 = list(param = c(0,1/2.72))))))



```

### CV

```{r}
#| eval: false
df_sf <- data1 %>% mutate(id = 1:nrow(data1)) %>% st_as_sf(coords =c("X","Y"))

# create buffer of size 300 (based on estimated range) centred at each site

buffer_25 <- st_buffer(df_sf, dist = 1.5) 

# empty lists to include the indexes of the leave-out-group for each observation i
I_i <- list()

# loop though each observation and store the leave-out-group based on the buffer
for( i in 1:nrow(df_sf)){

# Temporal filtering of data within a 2 years of span of  observation i
 df_sf_subset <- df_sf %>% 
   filter( between(time,left = df_sf$time[i]-2, right = df_sf$time[i]+2)) 
# Spatial filtering of the observations that are within the buffer of the ith observation
Buffer_i <-df_sf_subset %>% st_intersects(buffer_25[i,],sparse = FALSE) %>% # identify 
   unlist()

# obtain the indexes of the leave out group
I_i[[i]] <-  df_sf_subset[Buffer_i,] %>%  pull(id)

}

## Example for the the 200th test point  
# ggplot()+geom_sf(data=df_sf)+
#   facet_wrap(~year)+
#   geom_sf(data=df_sf[I_i[[200]],],color="orange")+
#   geom_sf(data = df_sf[200,],colour="purple") +
#   geom_sf(data=buffer_25[200,],color="red",alpha=0) 
  



```

## Model 2

```{r}
boundary = inla.nonconvex.hull(points = revi.data$coords, convex = .3)
mesh = inla.mesh.2d(boundary = boundary,
                    #   loc = cbind(data$X, data$Y),
                    max.edge = c(0.1,0.7),
                    min.angle = 20,
                    offset = c(.01, 1),
                    cutoff = 0.12,
)
ggplot() + inlabru::gg(mesh) +
  geom_point(data = data, aes(X,Y), pch = ".") +
  coord_equal() + theme_maps

bbox = data |> st_as_sf(coords = c("X","Y")) |> st_bbox()
(bbox[3] - bbox[1])/3

spde <- inla.spde2.pcmatern(
  mesh = mesh, 
  prior.range = c(5, 0.01),
  prior.sigma = c(1, 0.5)) 

```

This is a space-time model with linear predictor as $$
\eta_{st} = \beta_0 + f_1(\text{elev}) + f_2(t) + \omega(s) 
$$ with $f_1()$ and $f_2()$ as before while $\omega(s)$ is a gaussian spatial field

```{r}
data1 = data %>% dplyr::filter(time %in% yy ) %>%
  mutate(random = seq_along(X))

iset_sp <- inla.spde.make.index(name = "spatialfield",
                                n.spde =  spde$n.spde)

A_sp <- inla.spde.make.A(mesh = mesh, 
                         loc = cbind(data1$X, data1$Y))


stk <- inla.stack(data=list(Ycounts = data1$counts, 
                            Ncounts = data1$nvisits,
                            scale_mday = data1$scale_mday,
                            scale_mday2 = data1$scale_mday2,
                            scale_mtod = data1$mtod,
                            Int_det = 1), #the response
                  A=list(A_sp,1),  #the A matrix; the 1 is included to make the list(covariates)
                  effects=list(c(list(Int_occ=1), #the Intercept
                                 iset_sp),  #the spatial index
                               #the covariates
                               list(scale_elev = data1$scale_elev, 
                                    scale_elev2 = data1$scale_elev2, 
                                    time = data1$time,
                                    group_elev = data1$group_elev,
                                    scale_time = data1$scale_time,
                                    site = data1$site,
                                    random = data1$random)), 
                  #this is a quick name so yo can call upon easily
                  tag='dat')

formula3_2 <- inla.mdata(cbind(Ycounts,Ncounts),
                         Int_det, scale_mday, scale_mday2
                         ) ~ 
  -1 + Int_occ +  
  #time +
  #scale_elev + scale_elev2 + 
  f(time, model = "iid") + 
    f(group_elev, model = "rw2", values = val_elev) + 

  f(spatialfield, model=spde) 

formula3_2 <- inla.mdata(cbind(Ycounts,Ncounts),
                         Int_det,scale_mday, scale_mday2) ~ 
  f(group_elev, model = "rw2", values = val_elev) + 
  -1 + Int_occ +  #time +  scale_elev + scale_elev2
  f(time, model = "iid") + 
  f(spatialfield, model=spde) 




eps=1e-8 
time2 = system.time(model3_2 <- inla(formula3_2, 
                                     data=inla.stack.data(stk),  
                                     family= '0binomialS',  
                                     control.fixed =  list(prec = 1, prec.intercept = 1),
                                     control.predictor=list(A=inla.stack.A(stk),
                                                            compute=TRUE), 
                                     control.compute = list(dic = TRUE, waic = TRUE, 
                                                            config = TRUE), 
                                     verbose = F,
                                    #control.inla=list(cmin=eps, b.strategy="keep"),

                                     control.family = list(control.link = list(model = "logit"), 
                                                           link.simple = "logit",
                                                           hyper = list(beta1 = list(param = c(0,1/3), 
                                                                                   initial = 0),
                                                                      beta2 = list(param = c(0,1/3)),
                                                                      beta3 = list(param = c(0,1/3)),
                                                                      beta4 = list(param = c(0,1/3)),
                                                                      beta5 = list(param = c(0,1/3))))))




model3_2$summary.hyperpar
plot_inla_effects(model3_2$summary.random$group_elev)

```

## Model 3

The last model is defined as: $$
\eta_{st} = \beta_0 + f_1(\text{elev}) +  \omega(s,t) 
$$ with $f_1()$ is as before while $\omega(s,t)$ is a space-time gaussian spatial field with AR1 time component

```{r}


spde2 <- inla.spde2.pcmatern(
  mesh = mesh, 
  prior.range = c(1, 0.01),
  prior.sigma = c(1, 0.5)) 


data2 = data %>% dplyr::filter(time %in% yy) %>%
  mutate(random = seq_along(X))

iset_sp <- inla.spde.make.index(name = "spatialfield",
                                n.spde =  spde$n.spde,
                                n.group = length(yy))

A_sp <- inla.spde.make.A(mesh = mesh, 
                         loc = cbind(data2$X, data2$Y), 
                         group = data2$time)

stk <- inla.stack(data=list(Ycounts = data2$counts, 
                            Ncounts = data2$nvisits,
                            scale_mday = data2$scale_mday,
                            scale_mday2 = data2$scale_mday2,
                            scale_mtod = data2$mtod,
                            Int_det = 1), #the response
                  A=list(A_sp,1),  #the A matrix; the 1 is included to make the list(covariates)
                  effects=list(c(list(Int_occ=1), #the Intercept
                                 iset_sp),  #the spatial index
                               #the covariates
                               list(scale_elev = data2$scale_elev, 
                                    scale_elev2 = data2$scale_elev2, 
                                    time = data2$time,
                                    location = data2$site,
                                    group_elev = data2$group_elev,
                                    scale_time = data2$scale_time)), 
                  #this is a quick name so yo can call upon easily
                  tag='dat')

h.spec <- list(rho = list(prior = 'pc.cor0', param = c(0.5, 0.3)))


formula3_3 <- inla.mdata(cbind(Ycounts,Ncounts),
                         Int_det, scale_mday, scale_mday2) ~ 
  -1   + Int_occ + 
  f(group_elev, model = "rw2", values = val_elev) + 
  f(spatialfield, 
    model=spde2, 
    group = spatialfield.group, 
    control.group = list(model = 'iid'))

time3 = system.time(model3_3 <- inla(formula3_3, #the formula
                                     data=inla.stack.data(stk),  #the data stack
                                     family= '0binomialS',   #which family the data comes from
                                     control.fixed =  list(prec = 1, prec.intercept = 1),
                                     control.predictor=list(A=inla.stack.A(stk),
                                                            compute=TRUE),  #compute gives you the marginals of the linear predictor
                                     control.compute = list(dic = TRUE, waic = TRUE, 
                                                            config = TRUE), #model diagnostics and config = TRUE gives you the GMRF
                                    

                                     verbose = F,
                                     control.family = list(control.link = list(model = "logit"), 
                                                                                    link.simple = "logit",
                                                           hyper = list(beta1 = list(param = c(0,10), 
                                                                                   initial = 0),
                                                                      beta2 = list(param = c(0,10)),
                                                                      beta3 = list(param = c(0,10)),
                                                                      beta4 = list(param = c(0,10)),
                                                                      beta5 = list(param = c(0,10))))))


model3_3$summary.hyperpar
plot_inla_effects(model3_3$summary.random$group_elev)
```

# Results and Predictions

```{r}
#| label: sample
#| # posterior samples -------------------------------------------------------

sample1 = inla.posterior.sample(1000, model1)
sample2 = inla.posterior.sample(1000, model3_2)
sample3 = inla.posterior.sample(1000, model3_3)

```

## Results

### Running times

```{r}
table = data.frame(elapsed_Time = c(time0["elapsed"], time2["elapsed"], time3["elapsed"]),
                   DIC = c(model1$dic$dic, model3_2$dic$dic, model3_3$dic$dic),
                   WAIC = c(model1$waic$waic, model3_2$waic$waic, model3_3$waic$waic),
                   mlik = c(model1$mlik[1,1],model3_2$mlik[1,1],model3_3$mlik[1,1]))
rownames(table) = paste("Model", c(1:3))
kable(table)



model3_3$summary.hyperpar %>% round(digits=2)

loocv_m1 <- inla.group.cv(result = model1)
ULOOCV = mean(log(loocv_m1$cv),na.rm=T)

loocv_m2 <- inla.group.cv(result = model3_2)
ULOOCV2 = mean(log(loocv_m2$cv),na.rm=T)

loocv_m3 <- inla.group.cv(result = model3_3,)
ULOOCV3 = mean(log(loocv_m3$cv),na.rm=T)
```

### elevation effect

First we look at the effect of elevation in the three fitted models

```{r}
data.frame(rbind(model1$summary.random$group_elev,
                 model3_2$summary.random$group_elev,
                 model3_3$summary.random$group_elev),
           model = paste("Model", rep(1:3,
                                      each = length(model1$summary.random$group_elev$mean)))) %>%
  ggplot() + geom_line(aes(ID, -mean, color = model, group  = model)) +
  geom_ribbon(aes(ID,ymin= -X0.025quant, ymax = -X0.975quant, 
                  group = model, fill = model), alpha = 0.3)+
  labs(y="Logit-scaled occupancy probabilities",x="Standardized elevation values")+
    theme(text=element_text(family="serif", size=20),
                                               legend.text = element_text(size=16))+
      scale_fill_discrete(name="")+
  scale_colour_discrete(name="")

ggsave(filename = "smooth_effect.pdf",dpi = 300,width = 4000,units = "px")
```

## Predictions over space

```{r}
yy = c(1,9)
pred1 = pred_df %>% dplyr::filter(time%in%yy)
A3_2 = inla.spde.make.A(mesh= mesh, loc = cbind(pred1$x, pred1$y))
A3_3 = inla.spde.make.A(mesh= mesh, loc = cbind(pred1$x, pred1$y),
                        group = pred1$time)

func1 = function(...)
{
  aa = -((Intercept) + 
           group_elev[as.numeric(as.factor(pred1$group_elev))] +
           time[pred1$time] 
  )
  rand = rnorm(length(pred1$group_elev), 0, 1/sqrt(theta[5]))
  aa + rand
}
func3_2 = function(...)
{
  aa = -(Int_occ + 
           group_elev[as.numeric(as.factor(pred1$group_elev))] +
           time[pred1$time] +
           (A3_2 %*% spatialfield)[,1] )
  aa
}
func3_3 = function(...)
{
  aa = -(Int_occ + 
           group_elev[as.numeric(as.factor(pred1$group_elev))] +
           (A3_3 %*% spatialfield)[,1] 
  )
  aa
}
fix1 = inla.posterior.sample.eval(func1, sample1)
fix3_2 = inla.posterior.sample.eval(func3_2, sample2)
fix3_3 = inla.posterior.sample.eval(func3_3, sample3)

pred2 = pred1 %>%
  mutate(sd1 = apply(fix1,1,sd),
         mean1 = apply(fix1,1,mean),
         sd2 = apply(fix3_2,1,sd),
         mean2 = apply(fix3_2,1,mean),
         sd3 = apply(fix3_3,1,sd),
         mean3 = apply(fix3_3,1,mean)) 


# New facet label names for time variable
time.labs <-  c("2010", "2018") 
names(time.labs) <- c("1", "9")

# New facet label names for name variable
model.labs <- c("Model 1", "Model 2","Model 3")
names(model.labs) <- c("mean1", "mean2","mean3")

pred2 %>% dplyr::select(x,y,time, mean1, mean2, mean3) %>%
  pivot_longer(-c(x,y,time)) %>%
  ggplot() + geom_tile(aes(x,y,fill = value)) +
  coord_equal() + 
  facet_grid(time~name,labeller = labeller(time = time.labs, name = model.labs)) + scale_fill_scico(name="Occupancy \nprobability \n(logit-scaled)") + theme_maps +
   theme(text=element_text(family="serif", size=20),
                                               legend.text = element_text(size=16))

ggsave(filename = "space_time_Occ_lprobs.pdf",dpi = 300,width = 4000,units = "px")


# New facet label names for name variable
model.labs <- c("Model 1", "Model 2","Model 3")
names(model.labs) <- c("sd1", "sd2","sd3")

pred2 %>% dplyr::select(x,y,time, sd1, sd2, sd3) %>%
  pivot_longer(-c(x,y,time)) %>%
  ggplot() + geom_tile(aes(x,y,fill = value)) +
  coord_equal() + 
  facet_grid(time~name,labeller = labeller(time = time.labs, name = model.labs)) + scale_fill_scico(name="Occupancy \nprobability  sd\n(logit-scaled)") + theme_maps +
   theme(text=element_text(family="serif", size=20),
                                               legend.text = element_text(size=16))

ggsave(filename = "space_time_Occ_lprobsSD.pdf",dpi = 300,width = 4000,units = "px")

#' Probability of occurrence

probs1 = inla.link.logit(fix1, inverse = T)
quant1 = apply(probs1,1,quantile, c(0.025, 0.975))
probs2 = inla.link.logit(fix3_2, inverse = T)
quant2 = apply(probs2,1,quantile, c(0.025, 0.975))
probs3 = inla.link.logit(fix3_3, inverse = T)
quant3 = apply(probs3,1,quantile, c(0.025, 0.975))

pred2 = pred1 %>%
  mutate(mean1 = apply(probs1,1,mean),
         quant_range1 = quant1[2,]-quant1[1,],
         mean2 = apply(probs2,1,mean),
         quant_range2 = quant2[2,]-quant2[1,],
         mean3 = apply(probs3,1,mean),
         quant_range3 = quant3[2,]-quant3[1,]) 

pred2 %>% dplyr::select(x,y,time, mean1, mean2, mean3) %>%
  pivot_longer(-c(x,y,time)) %>%
  ggplot() + geom_tile(aes(x,y,fill = value)) +
  coord_equal() + 
   facet_grid(time~name,labeller = labeller(time = time.labs, name = model.labs)) + scale_fill_scico(name="Occupancy \nprobability") + theme_maps +
   theme(text=element_text(family="serif", size=20),
                                               legend.text = element_text(size=16))


ggsave(filename = "space_time_Occ_probs.pdf",dpi = 300,width = 4000,units = "px")

model.labs <- c("Model 1", "Model 2","Model 3")
names(model.labs) <- c("quant_range1", "quant_range2","quant_range3")

pred2 %>% dplyr::select(x,y,time, quant_range1, quant_range2, quant_range3) %>%
  pivot_longer(-c(x,y,time)) %>%
  ggplot() + geom_tile(aes(x,y,fill = value)) +
  coord_equal() + 
  facet_grid(time~name,labeller = labeller(time = time.labs, name = model.labs)) + scale_fill_scico(name="Difference in \nquantile") + theme_maps +
   theme(text=element_text(family="serif", size=20),
                                               legend.text = element_text(size=16))

ggsave(filename = "space_time_Occ_qunatiles.pdf",dpi = 300,width = 4000,units = "px")

```

## Parameters for the detection part of the model

```{r}
# detecion paramters ------------------------------------------------------

npar = 1
tab1 = rbind(model1$summary.hyperpar[1:npar,c(1,3,5)],
             model3_2$summary.hyperpar[1:npar,c(1,3,5)],
             model3_3$summary.hyperpar[1:npar,c(1,3,5)])
rownames(tab1) = c (c("Int detection1"),
                    c("Int detection2"),
                    c("Int detection3"))

kable(tab1, booktabs = TRUE, digits = 2) %>% pack_rows(
  index = c("Model 1" = npar, "Model 2" = npar, "Model 3" = npar))


```

## predict detection

```{r}

range(data$mday)
time = seq(min(data$mday), max(data$mday))


t1 = (time-mean(data$mday))/sd(data$mday)
t2 = (time^2-mean(data$mday^2))/sd(data$mday^2)
func_det = function(...)
{
  theta[1] + theta[2] * t1 + theta[3] * t2
}

det1 = inla.posterior.sample.eval(func_det, sample1)
det2 = inla.posterior.sample.eval(func_det, sample2)
det3 = inla.posterior.sample.eval(func_det, sample3)

d1 = data.frame(time = time,
                m1 = apply(inla.link.logit(det1,inverse = T) , 1,mean),
                q11 = apply(inla.link.logit(det1,inverse = T) , 1,quantile, 0.05),
                q12 = apply(inla.link.logit(det1,inverse = T) , 1,quantile, 0.95),
                
                 m2 = apply(inla.link.logit(det2,inverse = T) , 1,mean),
                q21 = apply(inla.link.logit(det2,inverse = T) , 1,quantile, 0.05),
                q22 = apply(inla.link.logit(det2,inverse = T) , 1,quantile, 0.95),
               
                m3 = apply(inla.link.logit(det2,inverse = T) , 1,mean),
                q31 = apply(inla.link.logit(det3,inverse = T) , 1,quantile, 0.05),
                q32 = apply(inla.link.logit(det3,inverse = T) , 1,quantile, 0.95))
              
d1 %>% ggplot() + 
  geom_ribbon(aes(time, ymin = q11, ymax = q12), alpha = 0.3, fill = "red") +
   geom_ribbon(aes(time, ymin = q21, ymax = q22), alpha = 0.3, fill = "blue") +
   geom_ribbon(aes(time, ymin = q31, ymax = q32), alpha = 0.3, fill = "black") +
  geom_point(data = data, aes(x = mday, y = counts/nvisits)) + 
  geom_smooth(data = data, aes(x = mday, y = counts/nvisits))

ggplot() + geom_point(data = data, aes(x = mtod,  y = counts/nvisits))  +
  geom_smooth(data = data, aes(x = mtod, y = counts/nvisits))

     
```

## Using spOccupancy

```{r}
library(spOccupancy)

revi.sp.occ.formula <- ~ scale(elev) + I(scale(elev)^2) + scale(years)
revi.sp.det.formula <- ~ scale(day) + I(scale(day)^2) + scale(tod)


z.inits <- apply(revi.data$y, c(1, 2), function(a) as.numeric(sum(a, na.rm = TRUE) > 0))
# Pair-wise distance between all sites
dist.hbef <- dist(revi.data$coords)
revi.sp.inits <- list(beta = 0, alpha = 0, z = z.inits,
                      sigma.sq = 1, phi = 3 / mean(dist.hbef),
                      sigma.sq.t = 1.5, rho = 0.2)
revi.sp.priors <- list(beta.normal = list(mean = 0, var = 2.72),
                       alpha.normal = list(mean = 0, var = 2.72),
                       sigma.sq.t.ig = c(2, 0.5),
                       rho.unif = c(-1, 1),
                       sigma.sq.ig = c(2, 1),
                       phi.unif = c(3 / max(dist.hbef), 3 / min(dist.hbef)),
                       nu.unif =c(0,1))

cov.model <- 'matern'
n.neighbors <- 5
ar1 <- FALSE

n.batch <- 600
batch.length <- 25
n.burn <- 10000
n.thin <- 20


# Approx. run time: ~ 2.5 min
out.sp <- stPGOcc(occ.formula = revi.sp.occ.formula,
                   det.formula = revi.sp.det.formula,
                   data = revi.data,
                   inits = revi.sp.inits,
                   priors = revi.sp.priors,
                   cov.model = cov.model,
                   n.neighbors = n.neighbors,
                   n.batch = n.batch,
                   batch.length = batch.length,
                   verbose = TRUE,
                   ar1 = ar1,
                   n.report = 200,
                   n.burn = n.burn,
                   n.thin = n.thin,
                   n.chains = 3)


out.sp|>summary()

# Number of prediction sites.
J.pred <- nrow(hbefElev)
# Number of prediction years.
n.years.pred <- 2
# Number of predictors (including intercept)
p.occ <- ncol(out.sp$beta.samples)
# Get covariates and standardize them using values used to fit the model
elev.pred <- (hbefElev$val - mean(revi.data$occ.covs$elev)) / sd(revi.data$occ.covs$elev)
year.pred <- matrix(rep((c(2010, 2018) - mean(revi.data$occ.covs$years)) /
            sd(revi.data$occ.covs$years),
                    length(elev.pred)), J.pred, n.years.pred, byrow = TRUE)
# Create three-dimensional array
X.0 <- array(1, dim = c(J.pred, n.years.pred, p.occ))
# Fill in the array
# Years
X.0[, , 2] <- year.pred
# Elevation
X.0[, , 3] <- elev.pred
# Elevation^2
X.0[, , 4] <- elev.pred^2
# Check out the structure
str(X.0)
# Indicate which primary time periods (years) we are predicting for
t.cols <- c(1, 9)
# Approx. run time: < 30 sec
coords.0 <- cbind(hbefElev$Easting,hbefElev$Northing)
out.pred <- predict(out.sp, X.0,coords.0, t.cols = t.cols, ignore.RE = TRUE, type = 'occupancy')
# Check out the structure
str(out.pred)
plot.dat <- data.frame(x = hbefElev$Easting,
                       y = hbefElev$Northing,
                       mean.2009.psi = apply(out.pred$psi.0.samples[, , 1], 2, mean),
                       mean.2018.psi = apply(out.pred$psi.0.samples[, , 2], 2, mean),
                       sd.2009.psi = apply(out.pred$psi.0.samples[, , 1], 2, sd),
                       sd.2018.psi = apply(out.pred$psi.0.samples[, , 2], 2, sd),
                       stringsAsFactors = FALSE)
# Make a species distribution map showing the point estimates,
# or predictions (posterior means)
dat.stars <- st_as_stars(plot.dat, dims = c('x', 'y'))
# 2009
ggplot() +
  geom_stars(data = dat.stars, aes(x = x, y = y, fill = mean.2009.psi)) +
  scale_fill_viridis_c(na.value = 'transparent') +
  labs(x = 'Easting', y = 'Northing', fill = '',
       title = '') +
  theme_bw()



data %>% 
  group_by(time) %>%
  summarise(m = mean(counts/nvisits)) %>%
  ggplot() + geom_point(aes(x = time, y = m)) 
```
